# 【JS表达式与操作符】

> 原创内容，转载请注明出处！

# 一、什么是表达式和运算符

表达式：由 **操作数** 和 **运算符** 组成的式子。

表达式的分类：算术、关系、逻辑、赋值、综合。

# 二、算术表达式

## 2.1 算术运算符

| 意义 | 运算符 |
| ---- | ------ |
| 加   | `+`    |
| 减   | `-`    |
| 乘   | `*`    |
| 除   | `/`    |
| 取余 | `%`    |

> 推荐一律使用 `()` 来强制规定优先级！

`+` 有 “加法” 和 “连字符” 两种作用，如果 `+` 的某一边是字符串那么就为 ”连字符“，否则为 ”加法“。

## 2.2 隐式类型转换

如果参与数学运算的某操作数不是数字类型，那么 JS 会自动将此操作数转换为数字型。

```javascript
3 * '4';		// 12
true + true;	// 2
false + 2;		// 2
3 * '2天'; 	   // NaN
"z" * "j";	    // NaN
3 + '2天'; 	   // '32天'
3 + null;		// 0
3 * '';			// 0
3 * ' ';		// 0
3 + '';			// '3'
3 + ' ';		// '3 '
```

> 隐式转换的本质是 JS 内部自动调用 Number() 函数

## 2.3 有关IEEE754

在 JS 中，有些小数的数学运算不是很精准。

```javascript
0.1 + 0.2;	// 0.30000000000000004
```

JS 使用了 IEEE754 二进制浮点数算术标准，这会使一些个别的小数运算产生 “丢失精度” 问题。

注意：不是所有的小数运算都会出现精度问题，只是少数部分。

> 几乎所有的高级语言都使用了 IEEE754 二进制浮点数算术标准。
>
> IEEE754 二进制浮点数算术标准是计算机底层编译标准，了解即可！

【解决办法】

在进行小数运算时，要调用数字的 `toFixed()` 方法保留指定的小数位数。

> `toFixed()` 括号内接受一个保留小数位数的参数。 

```javascript
(0.1 + 0.2).toFixed(2);				// '0.30'，默认得到一个字符串值
Number((0.1 + 0.2).toFixed(2));		 // 0.3
```

>  `toFixed()` 遵循（“四舍六入”，“五不一定”）原则。
>
>  ```javascript
>  (0.9945).toFixed(3);	// "0.995"
>  ```

>最后要注意浮点数的相等比较：
>
>```javascript
>1 / 3 === (1 - 2 / 3);	// false
>```
>
>这不是 JavaScript 的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：
>
>```javascript
>Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001;	// true
>```

> 还有一种解决技巧，就是将浮点数转换为整数进行计算：
>
> ```javascript
> 0.1 + 0.2;	// 0.30000000000000004
> (0.1 * 10 + 0.2 * 10) / 10;	// 0.3
> ```

## 2.4 幂和开根号

JS 中没有提供幂运算、开根号的运算符，需要使用 Math 对象的相关方法进行计算。

`Math.pow(a, b)`：求 a 的 b 次方。

`Math.sqrt(a)`：求 a 的平方根。

```javascript
Math.pow(2, 3);		// 8
Math.pow(3, 2);		// 9
Math.sqrt(81);		// 9
Math.sqrt(-81);		// NaN
```

## 2.5 向上取整和向下取整

`Math.ceil()`：向上取整。

`Math.floor()`：向下取整。

`Math.round()`：把一个数字舍入为最接近的整数（“四舍六入”，“五不一定”）

> 注意：向上、向下的标准是：X轴正方向为上！
>
> 负 ———— 0 ————> 正

```javascript
Math.ceil(2.4);			// 3
Math.floor(2.4);		// 2

Math.ceil(-2.4);		// -2
Math.floor(-2.4);		// -3

Math.ceil(2);			// 2
Math.floor(2);			// 2		
```

> 注意：由于底层的关系，无论是 `toFixed()` 还是 `Math.round()` 都不是完全遵循 “四舍五入”（无论正负），而是 “四舍六入，五不一定”，为什么非要这样呢？原因是没办法！因为小数在计算机底层的实现机制导致的问题！建议对于小数位数的处理不要用原生的函数来处理！最好是手动实现想要的处理代码，或者是借助第三方库！

# 三、关系表达式

## 3.1 关系运算符

| 意义       | 运算符 |
| ---------- | ------ |
| 大于       | `>`    |
| 小于       | `<`    |
| 大于或等于 | `>=`   |
| 小于或等于 | `<=`   |
| 等于       | `==`   |
| 不等于     | `!=`   |
| 全等于     | `===`  |
| 不全等于   | `!==`  |

## 3.2 相等和全等

两个等号 `==` 运算符，不考虑值的类型，它会进行**隐式转换**后比较**值的字面量**是否相等。

三个等号 `===` 运算符，不仅比较**值**是否相同，同时比较**类型**是否相同。

```javascript
5 == '5';		// true
5 === '5';		// false
```

```javascript
1 == true;			// true
1 === true;			// false

0 == false;			// true
0 === false; 		// false

0 == undefined;		// false
0 === undefined;	// false

undefined == null;	// true
undefined === null;	// false
```

> null 和 undefined 用 == 进行比较涉及隐式强制类型转换，ES5 规范中规定。
>
> === 比较为 false，是因为 null 与 undefined 类型不同。
>
> **建议没有特殊情况请一律使用 ===**

## 3.3 NaN不自等

NaN 作为一个特殊的数字类型值，它在用 `==` 比较的时候也有特殊的结果。

```javascript
NaN == NaN;			// false
NaN	=== NaN;		// false
```

【如何判断某变量值为 NaN】

`isNaN()` 函数可以用来判断变量值是否为 NaN。

```javascript
isNaN(NaN);		// true
isNaN(5);		// false
isNaN('5');		// false
```

> 但 isNaN() 也不好用，它的机理是：只要该变量传入 Number() 的执行结果是 NaN，则 isNaN() 函数都会得到 true。
>
> 对于，undefined 和 null，这种情况一般来说需要先进行单独判断，再进行 isNaN 判断。
>
> ```javascript
> isNaN(undefined);	// true
> isNaN('3天');	   // true
> isNaN(null);		// false
> ```

## 3.4 JS中没有连比

例如：`3 <= a <= 15` 的写法是错误的，应该为：`a >= 3 && a <= 15`。

# 四、逻辑表达式

## 4.1 逻辑运算符

| 意义 | 运算符 |
| ---- | ------ |
| 非   | `!`    |
| 与   | `&&`   |
| 或   | `||`   |

## 4.2 非运算

`!` 表示 “非”，也可以称为 “置反运算”。

`!` 是一个 “单目运算符”，只需要一个操作数。

置反运算的结果一定是布尔值。

```javascript
!true;			// false
!false;			// true
!0;				// true
!undefined;		// true
!'';			// true
!' ';			// false
!null;			// true
!'imooc';		// false
```

> `!!` 常用于确定一个值的布尔属性。
>
> ```javascript
> !!true;		// true
> !!0;		// false
> !!'';		// false
> !!' ';		// true
> !!'imooc';	// true
> ```

## 4.3 与运算

`&&` 是 “双目运算符”。

核心：`全真为真、有假即假`。

## 4.4 或运算

`||` 是 “双目运算符”。

核心：`全假为假、有真即真`。

## 4.5 短路运算

`&&` 与 `||`，都属于 “短路运算符”。

**（1）`&&` 短路运算**

由于 `&&` 运算的核心是：“全真为真、有假即假”，所以：

- 如果 `a && b` 中 `a` 为真，那么该表达式的值由 `b` 决定（计算 a 又计算 b）
- 如果 `a && b` 中 `a` 为假，那么该表达式的值由 `a` 决定（只计算 a）

```javascript
3 && 6;				// 6
undefined && 15;	// undefined
15 && undefined;	// undefined
null && 2;			// null
'' && 16;			// ''
NaN && undefined;	// NaN
```

**（2）`||` 短路运算**

由于 `||` 运算的核心是：“全假为假、有真即真”，所以：

- 如果 `a || b` 中 `a` 为真，那么该表达式的值由 `a` 决定（只计算 a）
- 如果 `a || b` 中 `a` 为假，那么该表达式的值由 `b` 决定（计算 a 又计算 b）

```javascript
3 || 6;				// 3
0 || 6;				// 6
null || undefined;	// undefined
'a' || 'b';			// 'a'
NaN || null;		// null
```

## 4.6 逻辑运算的优先级

优先级：`!` > `&&` > `||`

```javascript
!true || true;		// true
3 && 4 || 5 && 6；  // 4
```

> 推荐使用 `()` 来规定优先级。

# 五、赋值表达式

## 5.1 赋值运算符

| 意义     | 运算符                       |
| -------- | ---------------------------- |
| 赋值     | `=`                          |
| 快捷赋值 | `+=`、`-=`、`*=`、`/=`、`%=` |
| 自增运算 | `++`                         |
| 自减运算 | `--`                         |

## 5.2 赋值运算产生值

赋值运算也产生值，赋值号后面的值将作为 “赋值运算表达式的值”。

```javascript
var a;
console.log(a = 4);		// 4
```

这就意味着，可以连续使用赋值运算符。

```javascript
var a, b, c;
a = b = c = 15;
console.log(a);		// 15
console.log(b);		// 15
console.log(c); 	// 15
```

> 在实际开发中不建议使用连续赋值！

## 5.3 快捷赋值

快捷赋值运算符表示在 “原数值” 基础上进一步进行运算。

## 5.4 自增自减运算

`a++`：先用再加；`++a`：先加再用。

`a--`：先用再减；`--a`：先减再用。

# 六、综合运算的运算顺序

非运算 > 数学运算 > 关系运算 > 逻辑运算

> 建议使用 `()` 来规定优先级。

