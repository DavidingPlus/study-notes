---
title: 计算机高级图形学 期末复习
categories:
  - 校内课程
  - 计算机高级图形学
abbrlink: 1b712153
date: 2025-11-04 21:40:00
updated: 2025-11-11 20:25:00
---

<meta name="referrer" content="no-referrer"/>

# 第一章 绪论

## 本章复习重点

- 图形学和图像学的区别。
- 走样的原因和反走样的概念。
- 选择题（直线算法）。
- 光栅显示系统。

<!-- more -->

## 计算机图形学概述

|          | 图形处理                                                     | 图像处理                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据来源 | **多来源于主观世界，人为地由计算机产生，由数据描述而生成图形。** | **多来源于客观世界，来自对实物的拍摄、捡取。**               |
| 处理方法 | 图形处理技术包括：几何变换，拟合，图形操作，图形模型产生，图形处理，隐藏线，面的消除，浓淡处理，色彩纹理处理，图案生成等。 | 图像处理技术包括：图像几何修正（校正），图像采集、存储、编码、滤波、增强、压缩、复原、重建、图形理解识别等。 |
| 理论基础 | 多利用数学矩阵代数、计算几何、分形几何等。                   | 多利用二维数字信号滤波，各种信号正交变换等。                 |
| 应用领域 | 多应用 CAD/CAM/CAE/CAI 等领域，以及计算机艺术、计算机模拟、计算机动画、多媒体系统应用等。 | 多应用于多媒体系统，医学，遥感遥测，工业控制，监测监视，天文气象，军事侦察等。 |

## 图形学研究内容

1. 建模：创建用计算机表示的三维物体模型，主要是形状表述与定义。
2. 渲染：通过各种矩阵变换从模型产生物体的二维图像，主要考虑光照、透视变换。
3. 动画：描述物体运动变化。

## 光栅扫描系统

### 随机扫描与光栅扫描

随机扫描技术的本质是按照显示命令的任意顺序，将电子束从一个端点偏转到另一个端点。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203112346.png" alt="image-20251104203112346" style="zoom:50%;" />

光栅图形具有对显示区域填充颜色或图案的能力，存储的图像更加易于操作。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203145253.png" alt="image-20251104203145253" style="zoom:60%;" />

光栅显示器上的图形由光栅（raster）形成。

**光栅是一组互相平行的水平扫描线。每行扫描线是由大小一致的显示单元组成的显示序列，每一显示单元称为一个像素，可显示给定的颜色和灰度。**

光栅显示器将显示图元（primitive）如线、文字、填充颜色或图案区域等，以像素的形式存储到一个刷新缓冲器中。

### 光栅扫描系统

构成：

1. 帧缓冲区（Frame Buffer）。
2. 视频控制器（Video Controller）。
3. 显示处理器（Display Processor / GPU）。

视频控制器如何实现基本刷新：

1. 有两个寄存器用来存放屏幕像素的坐标。
2. 存储在帧缓冲区中该像素对应位置的值被取出，并用来设置 CRT 电子束的强度值。

显示处理器的主要任务是**将应用程序给出的图形定义数字化为一组像素强度值，并存放在帧缓冲区中**。这个数字化过程称为**扫描转换（Scan Conversion）**。

### 直线段的扫描转换算法

当我们对直线进行光栅化时，需要在显示器有限个像素中，确定最佳逼近该直线的一组像素，并且按扫描线顺序，对这些像素进行写操作，这个过程称为用显示器绘制直线或直线的扫描转换。

三种算法：

1. 基本增量算法（DDA）数值微分算法。
2. 中点画线算法。
3. **Bresenham 算法（使用最广泛）。**

#### DDA 算法

在一个坐标轴上以单位间隔对线段取样，则另一个坐标轴以常数 m 或 1/m 变化，从而获得线段上各像素点。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104205009793.png" alt="image-20251104205009793" style="zoom:50%;" />

算法迭代公式：
$$
\text{若 } |m| \le 1:
\begin{cases}
x_{k+1} = x_k + 1, \quad y_{k+1} = y_k + m, & (x_a < x_b) \\
x_{k+1} = x_k - 1, \quad y_{k+1} = y_k - m, & (x_a > x_b)
\end{cases}

\\

\text{若 } |m| \ge 1:
\begin{cases}
y_{k+1} = y_k + 1, \quad x_{k+1} = x_k + \dfrac{1}{m}, & (y_a < y_b) \\
y_{k+1} = y_k - 1, \quad x_{k+1} = x_k - \dfrac{1}{m}, & (y_a > y_b)
\end{cases}
$$

#### Bresenham 算法

**只用整数计算寻找最接近实际直线的整数坐标。即从 Yk 和 Yk + 1 中取出最贴近 y 坐标的点作为拟合点，但只通过整数计算。**

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104211634765.png" alt="image-20251104211634765" style="zoom:50%;" />

推导过程如下：
$$
\\
\textbf{假定：} \quad 0 < m < 1
\\

已知点 (x_k, y_k)，求下一点 (x_{k+1}, y_{k+1})。(x_{k+1}, y_{k+1}) 的两种可能为：(x_{k+1}, y_k) \quad \text{或} \quad (x_{k+1}, y_k + 1)。其中：x_{k+1} = x_k + 1
\\

\textbf{推导：}
\\
设两点与理想直线的距离分别为 d_1、d_2：

\\
\begin{aligned}
d_1 &= y - y_k = m x_{k+1} + b - y_k, \\
d_2 &= y_{k+1} - y = y_{k+1} - (m x_{k+1} + b).
\end{aligned}
\\
因此：d_1 - d_2 = 2m x_{k+1} - 2y_k + 2b - 1
\\
令：m = \frac{\Delta y}{\Delta x}
\\
代入上式，引入决策参数 P_k 表示相对距离：
\\
P_k = \Delta x (d_1 - d_2) = 2\Delta y x_k - 2\Delta x y_k + C
\\
其中：C = 2\Delta y + \Delta x (2b - 1)
\\

\textbf{推论：}
\\
\begin{cases}
P_k < 0, & \text{则选择 } y_{k+1} = y_k \\
P_k \ge 0, & \text{则选择 } y_{k+1} = y_k + 1
\end{cases}
\\

P_k 的递推公式：
\\

由
\\
\begin{aligned}
P_{k+1} &= 2\Delta y x_{k+1} - 2\Delta x y_{k+1} + C, \\
P_k &= 2\Delta y x_k - 2\Delta x y_k + C,
\end{aligned}
\\

两式相减得：
\\
P_{k+1} - P_k = 2\Delta y (x_{k+1} - x_k) - 2\Delta x (y_{k+1} - y_k)
\\ = 2\Delta y - 2\Delta x (y_{k+1} - y_k)

\\
\therefore \; {P_{k+1}} \text{ 的递推公式：}
\\

P_{k+1} =
\begin{cases}
P_k + 2\Delta y, & (P_k < 0) \\[6pt]
P_k + 2\Delta y - 2\Delta x, & (P_k \ge 0)
\end{cases}
\\

初始值为：\\

P_0 = 2\Delta y - \Delta x
$$

#### 中点画线算法

用判别式判断点与直线的关系。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213004956.png" alt="image-20251104213004956" style="zoom:50%;" />

算法思路：
$$
F(x, y) = (m x + b) - y \\[6pt]
F(x_{k+1},\, y_k + 0.5) = 0, 
\quad \text{对应点 } (x_{k+1},\, y_{k+1}) \text{ 可能为 } (x_{k+1},\, y_k + 1) \text{ 或 } (x_{k+1},\, y_k) \\[6pt]
\begin{cases}
F(x_{k+1},\, y_k + 0.5) < 0, & \text{中点在直线上方，选择 } (x_{k+1},\, y_k) \\[6pt]
F(x_{k+1},\, y_k + 0.5) > 0, & \text{中点在直线下方，选择 } (x_{k+1},\, y_k + 1)
\end{cases}
$$

### 走样与反走样

对于光栅系统来说，只能用光栅网格上的像素近似地描绘平滑的直线、多边形和圆、椭圆等曲线图元。如果引起了图中看到的**锯齿状或阶梯状的边界线问题**，在图形学中称为“走样”。

用于减少或消除这种现象的技术称为“反走样”。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213414197.png" alt="image-20251104213414197" style="zoom:67%;" />

# 第二章 颜色模型

## 本章复习重点

- 什么是设备无关的颜色模型。
- 什么是设备相关的颜色模型。
- RGB 和 CMY 颜色模型的比较。
- 哪些颜色模型是设备相关的？哪些颜色模型是设备无关的？
- 颜色模型之前的转换。

## 颜色模型

颜色模型就是用一组数值来描述颜色的数学模型。

**设备无关**的颜色模型：这类颜色模型是基于人眼对色彩感知的度量建立的数学模型，这些颜色模型主要用于计算和测量。

**设备相关**的颜色模型：以最常见的 RGB 模型为例，一组确定的 RGB 数值，在一个 LED 屏上显示，最终会作用到三色 LED 的电压上。这样一组值在不同设备上解释时，得到的颜色可能并不相同。

颜色模型是某个三维空间中的一个可见光子集。**任何一个色彩域都只是可见光的子集，任何一个颜色模型都无法包含所有的可见光。**

**三原色：红、绿、蓝。**

## RGB 颜色模型

三维直角坐标颜色系统中的一个单位正方体。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185701763.png" alt="image-20251109185701763" style="zoom:75%;" />

RGB 颜色模型构成的颜色空间是 CIE 原色空间的一个真子集。RGB 三原色是**加性原色**。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185942413.png" alt="image-20251109185942413" style="zoom:66%;" />

RGB 颜色模型通常用于彩色阴极射线管和彩色光栅图形显示器。

## CMY 颜色模型

**CMY 颜色模型是以红、绿、蓝三色的补色青（Cyan）、品红（Magenta）、黄（Yellow）为原色构成的颜色模型。**

CMY 颜色模型常用于**从白光中滤去某种颜色**，故称为**减色原色**空间。

![image-20251109185958804](https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185958804.png)

CMY 颜色模型对应的直角坐标系的子空间与 RGB 颜色模型对应的子空间几乎完全相同。

## RGB 和 CMY 颜色模型的对比

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190252186.png" alt="image-20251109190252186" style="zoom:60%;" />

## HSV 颜色模型

HSV 颜色模型是面向用户的。在 HSV 颜色模型中，每一种颜色和它的补色相差 180 度。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190711853.png" alt="image-20251109190711853" style="zoom:80%;" />

HSV 颜色模型的优点：

- 符合人眼对颜色的感觉。
- 当采用 RGB（或者 CMY）颜色模型时，改变某一颜色的属性，比如改变色调就必须同时改变 R、G、B（或者 C、M、Y）三个坐标；而采用 HSV 颜色模型时**只需改变 H 坐标**。即它的三个坐标是独立的。
- HSV 颜色模型构成的是一个**均匀**的颜色空间，采用线性的标尺，彩色之间感觉上的距离与 HSV 颜色模型坐标上点的欧几里德距离成正比。

## CIE（国际照明委员会）颜色模型

CIE 颜色模型包括一系列颜色模型，这些颜色模型是由国际照明委员会提出的，是**基于人的眼睛对 RGB 的反应，被用于精确表示对色彩的接收**。

CIE 是**设备无关性**：

- 被用来定义所谓的**独立于设备**的颜色。
- 它能够在任何类型的设备上产生真实的颜色，例如：扫描仪、监视器和打印机。
- 很适合计算机描述颜色的范围。

### CIE XYZ

XYZ 三刺激值的概念是以色视觉的三元理论为根据的，它说明**人眼具有接受三原色(红、绿、蓝)的接受器**，而所有的颜色均被视作该三原色的混合色。

CIE 制定了一种配色函数，能和 RGB 通过矩阵运算进行转化。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191400975.png" alt="image-20251109191400975" style="zoom:40%;" />

**颜色的概念可以分为两部分：亮度（光的振幅，即明暗程度）、色度（光的波长组合，即具体某种颜色）。**我们将光的亮度 Y 变量分离出来，之后用比例来表示三色刺激值：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191459184.png" alt="image-20251109191459184" style="zoom:60%;" />

可以发现，r、g、b 三者和为 1，只要知道其中两个就能求出另外一个。然后再和光的亮度 Y 结合起来，就能绘制 Yxy 颜色空间。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191806008.png" alt="image-20251109191806008" style="zoom:50%;" />

### CIE L\*a\*b\*

L\*a\*b\* 颜色空间是在 1976 年制定的，它是 CIE XYZ 颜色模型的改进型，以便**克服 Yxy 颜色空间存在的在 x、y 色度图上相等的距离并不相当于所觉察到的相等色差的问题**。同样是一种描述人类视觉感知的、设备无关的颜色模型。

L\*a\*b\* 的概念图：

- L：明亮度。
- a：从绿色到红色。
- b：从蓝色到黄色。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109192447257.png" alt="image-20251109192447257" style="zoom:50%;" />

与 XYZ 比较，CIE L\*a\*b\* 颜色更适合人眼的感觉。

利用 CIE L\*a\*b\*，颜色的亮度（L）、灰阶和饱和度（a、b）可以单独修正，这样，图像的整个颜色都可以在不改变图像或其亮度的情况下，发生改变。

## YUV

“Y” 表示明亮度（Luminance），“U” 和 “V” 分别表示色度（Chrominance）和浓度（Chroma)。

**采用 YUV 颜色空间的重要性是它的亮度信号 Y 和色度信号 U、V 是分离的。**这样能解决彩色电视机和黑白电视机的兼容问题，使黑白电视机也能接收到彩色信号。如果只有 Y 信号分量而没有 U、V 分量，那么这样表示的图就是黑白灰度图。

## 各种颜色模型之间的转换

各种颜色模型之间的转换一般是以 RGB 和 CIE XYZ 作为桥梁进行的。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193132489.png" alt="image-20251109193132489" style="zoom:50%;" />

### RGB 和 CMY

RGB 的取值通常是 0 ~ 255 的整数。

```markdown
C = 255 – R
M = 255 – G
Y = 255 – B
```

### RGB 和 HSV

1. 查表法

最可靠方法：

把 RGB 坐标转换为 1931 CIE XYZ 系统中的 (x， y， Y) 坐标。根据 (x， y， Y) 查找对应表，得到相应的 (H， S， V) 坐标。逆向操作则可以从 HSV 坐标转换到 RGB 坐标。

xyY 坐标与 HSV 坐标的对照表已由色度学实验得到。这种方法需要依赖对照表，比较笨重。

2. 数学公式

从 RGB 到 HSV：

设 m=max(r, g, b)，n=min(r, g, b)。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193605016.png" alt="image-20251109193605016" style="zoom:80%;" />

从 HSV 到 RGB：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193725839.png" alt="image-20251109193725839" style="zoom:50%;" />

### RGB 和 CIE XYZ

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193801097.png" alt="image-20251109193801097" style="zoom:67%;" />

### CIE XYZ 和 CIE L\*a\*b\*

L 的范围是 0 ~ 100，a, b 的范围是 -300 ~ 300。从 -a 到 +a 表示绿到红过渡，-b 到 +b 表示蓝到黄过渡。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193926183.png" alt="image-20251109193926183" style="zoom:77%;" />

### RGB 和 CIE YUV

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193949447.png" alt="image-20251109193949447" style="zoom:80%;" />

# 第三章 物体表示

## 本章复习重点

- 什么是建模坐标系，和世界坐标系的区别。
- OBJ 数据结构。
- 什么是 BREP，其结构中包含哪些信息。
- 半边数据结构。
- 多边形的优缺点。
- Bézier 曲线优缺点。
- NURBS 曲线和 B 样条曲线的改进是什么。
- 参数曲线的优缺点。
- 细分曲面的作用。
- 细分曲面的原理。
- Catmull-Clark subdivision。
- 有哪些常见的细分规则。
- 细分曲面的翼边存储。
- 物体的 CSG 表示。
- 什么是分形几何。
- 分型维数计算。
- L- 系统，能够用 L- 系统绘制物体。

## 物体的集合表示

### 坐标表示

一些概念：

1. 世界坐标系(WC)：场景参照坐标系，一个场景只有一个世界坐标系。
2. 观察坐标系(VC)：根据场景观察时的视点和观察方向所建立的坐标系。
3. 投影坐标(PC)：观察坐标系下场景的二维投影坐标。
4. 设备坐标系(DC)或屏幕坐标系：该场景的世界坐标系描述转换为一个或多个输出设备参照系来显示。该坐标系依赖于具体的显示输出设备。
5. 规范化坐标系(NC)：指独立于具体物理设备的一种坐标系，它的显示范围在 x 和 y 上都是 0 到 1，主要用于在计算机内部处理图形，对一个具体物理设备，NC 与 DC 仅仅是相差一个比例因子，NC可被看成是一个抽象的图形设备。 

在一个世界坐标系中，由许多物体组成。不同物理的几何描述和空间坐标系密切相关，在不同坐标系中有着不同的表示方式。**选择某个空间坐标系能使得该物体的几何表示最简单，这就是建模坐标系。**

例如，一个单位正方体在世界和建模坐标系中的不同表示如下。明显建模坐标系更简洁。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202426738.png" alt="image-20251109202426738" style="zoom:67%;" />

建模坐标系除了形式简洁，还方便几何操作。在同一几何场景中，一个物体可能会多次出现，它们可以通过复制加变换的方式得到：标准体素＋变换＝新的物体。

例如，以下是在建模和世界坐标系中旋转一个圆柱面。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202703686.png" alt="image-20251109202703686" style="zoom:60%;" />

### 多边形表示

物体的多边形表示是通过大量的平面片，三角形、四边形以及 n 边形。本质是**线性表示形式**。

#### 数据来源

一个物体经过三维测量和扫描以后，原始数据一般是三维空间中的点集。通过适当的重建算法得到其多边形的表示。

常用物体外形用数学表示方法包括参数曲面、细分曲面、隐式曲面等。

#### 表示方法：OBJ 格式

重点！！！

1. **顶点坐标表（x, y, z）：每个顶点处可能有多个平面片，一般情况下顶点数小于面片数。**
2. **纹理坐标表（u, v）：控制纹理映射时纹理在表面上的位置。**
3. **法向表 (nx, ny, nz) ：控制物体绘制时的着色光滑程度。如果顶点法向为取作该面片的法向，绘制出来的多边形物体棱角分明如果顶点法向是周围面片法向的某种平均，则绘制结果是光滑的。**
4. **面表：由指向顶点、纹理坐标以及法向的指针组成。**

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203355330.png" alt="image-20251109203355330" style="zoom:67%;" />

#### 数据结构

##### BRep 表示

**边界表示，也称为 BRep 表示**，它是几何造型中最成熟、无二义的表示法。**实体的边界通常是由面的并集来表示，而每个面又由它所在的曲面的定义加上其边界来表示，面的边界是边的并集，而边又是由点来表示的。**

在边界表示法中，边界表示按照**体－面－环－边－点**的层次，详细记录构成形体的所有几何元素的几何信息及其相互连接的拓朴关系。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203820619.png" alt="image-20251109203820619" style="zoom:60%;" />

1. 顶点：0 维度几何元素。
2. 边：一维几何元素。对正则形体，边是两邻面的交集，对非正则形体，边有可能是多个邻面的交集。边的形状可以是直线，也可以是曲线。
3. 环：二维几何元素。有序、有向边（直线段或曲线段）组成的面的封闭边界。外环边通常按逆时针方向排序，内环边通常按顺时针方向排序。
4. 面：二维几何元素。可以无内环，但必须有且只有一个外环。面有方向性，一般用其外法线方向作为该面的正向。面的形状可以是平面，也可以是曲面。
5. 体：三维几何元素。由封闭表面围成的空间，其边界是有限面的并集。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204101621.png" alt="image-20251109204101621" style="zoom:67%;" />

##### 半边数据结构

半边结构（Half-Edge Structure）：可定向的二维流形及其子集。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204222651.png" alt="image-20251109204222651" style="zoom:55%;" />

每条边被记为两条半边，记录每条半边：

- 起始顶点的指针。
- 邻接面的指针(如果为边界，指针为 NULL)。
- 下一条半边(逆时针方向)。
- 相邻的半边。
- 前一条半边(可选)。

面：边界上的一条半边。

顶点：

- 坐标值。
- 指向以此顶点为起始端点的半边。

对于一个半边数据结构的简单形式，一个面仅仅需要储存一条围绕它的半边的指针。在半边数据结构中的点储存着 x，y，z 的位置和以其为起始点的半边的指针。

一个半边结构的实例：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204623522.png" alt="image-20251109204623522" style="zoom:60%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204648499.png" alt="image-20251109204648499" style="zoom:60%;" />

半边结构的优势和不足：

- 优势：查询时间 O(1)， 操作时间 (通常) O(1)。
- 缺点：只能表示可定向流形，信息冗余。

#### 优势与不足

优势：

- 表示简单。
- 可以表示具有任意拓扑的物体。
- 可以表示具有丰富细节的物体。
- 大部分图形硬件支持多边形物体的加速绘制。

不足：

- 逼近表示，难以满足交互时放大要求。
- 难以用传统方法修改(编辑)物体外形。
- 缺乏解析表达式，几何属性计算困难。
- 在表示复杂拓扑和具有丰富细节的物体时，数据量庞大，建模、编辑、绘制、存储的负担重。

## 分形

普通几何学研究的对象，一般都具有整数的维数。比如，零维的点、一维的线、二维的面、三维的立体、乃至四维的时空。但是现实生活中象弯弯曲曲的海岸线这些对象就不能用传统欧几里德几何学的整数维描述或者说测量了。**要描述这一大类复杂无规的几何对象，就引入了分形理论，把维数视为分数维数。**这是几何学的新突破，引起了数学家和自然科学者的极大关注。

**分形的本意是不规则的、破碎的、分数的。是指以非整数维形式填充空间的形态特征。**分形几何通俗一点就是研究无限复杂但具有一定意义下的自相似图形和结构的几何学，基本思想是**客观事物具有自相似的层次结构，局部与整体在形态、功能、信息、时间、空间等方面具有统计意义上的相似性，称为自相似性**。

如何计算分型维数？

如果**某图形是由把原图缩小为 1/a 的相似的 b 个图形所组成**，有：
$$
a^D=b, D=logb/loga
$$
则指数 D 称为相似性维数，D 可以是整数，也可以是分数。

**分形体没有特征尺度，不能用一般测度即长度、面积、体积这类几何对象的特征量来表示**，只能用分形维数(Fractal dimension，也即“分维”)来度量，因而分维已成为描述无标度现象的特征参数。

分形树：以自然界中的丫字形树杈为生成元，将生成元在每一个层次上不断重复，会得到分形树。

分形树实现算法：递归算法、LS 文法、迭代函数系统算法。

<img src="https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095509626.png" alt="image-20251110095509626" style="zoom: 50%;" />

“递归”，这两个字用得十分好。递，即依次递变；归，即向一个方向归拢。“分形”，故名思议是指把一个形状细分为同样的形状。

分形几何的主要特征：

- 自相似性质：分形物体的任何一个部分都和物体整体具有某种程度的相似。
- 无限小细节性质：当无限地放大分形物体时，物体总是表现有细节，而不是像欧氏空间的物体一样最终会表现出光滑性。
- 维数非整数。

分形的自我相似，自我复制和自我嵌套用递归算法来实现是合适的，事实上经典分形图的绘制大多数可采用**递归算法**。一个很经典的例子就是 Koch 雪花曲线。

![image-20251110095853380](https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095853380.png)



计算 Koch 的分形维度。Koch 曲线是把一条直线缩小为 1/3 的相似的 4 个图形组成，根据定义是 log4/log3。

分形艺术的特点：

- 自相似性。
- 极小性。
- 嵌套性。
- 缠绕性。

# 第四章 图形渲染通道

## 本章复习重点

- 掌握图形渲染通道由那几个部分组成。
- 每一个功能点的作用。

## 渲染

渲染：通过几何物体生成真实可见图像的过程。

用点线面描述物体：

- 融合了数学表达。
- 物体集合的代表。

渲染物体：

- 渲染通道 render pass (Vulkan)。
- 渲染管线 rendering pipeline (OpenGL)。
  - 立即渲染模式（Immediate mode，也就是固定渲染管线）。
  - 核心模式(Core-profile, V 3.2)。

3D 渲染管线的三个阶段：

- 应用阶段：模型、数据读取、交互。
- 几何阶段。
- 光栅化阶段。

## 照相机模型

最通用的模式是**小孔成像模型**。所有捕捉到的光线都沿着指向焦点的路径到达，没有镜头变形（所有物体都处于焦点位置）。传感器响应与射线成比例。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111190809048.png" alt="image-20251111190809048" style="zoom:60%;" />

### 照相机参数

内参：在小孔成像模型中有一个光点P，其将光以直线的方式穿过纸板的小孔(光心），射到显示纸板（物理成像平面）上，其坐标系结构如下图所示。而内参的作用即是在知道P的x、y、z后可以求出x\`、y\`。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191053719.png" alt="image-20251111191053719" style="zoom:60%;" />

外参：假象你的头部就是三维世界的中心，相机、篮球都有一个坐标，但是现在要知道的是相机中照片中的篮球的一个点的位置，因此应该将以你头部为中心的世界转换为以相机焦点为中心的世界，这样不就更直观了么。所以第一步就是求外参矩阵，然后把 xw,yw,zw 转换为以相机为中心的世界中的坐标 xc,yc,zc。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191229526.png" alt="image-20251111191229526" style="zoom:60%;" />

第二步，就是小孔成像问题，将转换为相机为中心世界的 xw,yw,zw，利用相机内参转换为图片中的点的位置，在将图片中的点转换为是哪个像素（像素坐标）。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191302377.png" alt="image-20251111191302377" style="zoom:67%;" />

## 渲染通道

经典的 3D 渲染通道：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192044693.png" alt="image-20251111192044693" style="zoom:55%;" />

### 模型变换

将所有场景中的点 3D “世界”变换到世界坐标系。大小缩放、平移、旋转物体，**建模坐标系 -> 世界坐标系**。

### 光线模拟

光照参数：光源发散、表面反射、大气衰减、相机感应。

直接光照模型、全局光照模型。

### 视窗转换

旋转转换世界坐标系为相机坐标系。**世界坐标系 -> 视窗坐标系**。

### 裁剪

去掉视窗外的几何物体部分。

### 投影变换

应用透视原理。**视窗坐标系 -> 场景/图像坐标系**。

### 光栅化

转换图像坐标系为像素和颜色。

# 第五章 变换

## 本章复习重点

- 齐次坐标系及其作用。
- 二维平移，旋转、缩放矩阵。
- 理解模型变换、取景变换、投影变换、设备变换、视窗变换的作用。
- 一点透视、两点透视、三点透视。

## 几何（模型）变换

### 基本变换

#### 2D 平移

图形对象沿直线运动产生的变换。
$$
x' = x + t_x
\\
y' = y + t_y
\\
\\

P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

T = \begin{bmatrix}
t_x \\
t_y
\end{bmatrix}

\\
\begin{bmatrix}
x' \\
y'
\end{bmatrix}
=
\begin{bmatrix}
x \\
y
\end{bmatrix}
+
\begin{bmatrix}
t_x \\
t_y
\end{bmatrix}
\\

P' = P + T
$$

#### 2D 旋转

图形对象沿圆弧路径运动产生的变换。

基准点(pivot)，坐标原点或任意点。旋转角 θ。方向,约定：逆时针为正。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112104312207.png" alt="image-20251112104312207" style="zoom:67%;" />
$$
P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

R = \begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}

\\

\begin{bmatrix}
x' \\
y'
\end{bmatrix}

=

\begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}

\begin{bmatrix}
x \\
y
\end{bmatrix}

\\

P' = R \cdot P
$$


#### 2D 缩放

改变图形对象大小的变换。
$$
P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

S = \begin{bmatrix}
S_x & 0 \\
0 & S_y
\end{bmatrix}

\\

\begin{bmatrix}
x' \\
y'
\end{bmatrix}

=

\begin{bmatrix}
S_x & 0 \\
0 & S_y
\end{bmatrix}

\begin{bmatrix}
x \\
y
\end{bmatrix}

\\

P' = S \cdot P
$$
2D 缩放讨论：

1. 如果 |Sx| 或 |Sy| 大于 1，则表示图形在 X 轴方向或 Y 轴方向放大；
2. 如果 |Sx| 或 |Sy| 小于 1，则表示图形在 X 轴方向或 Y 轴方向缩小；
3. 如果 |Sx| = |Sy|，则表示均匀缩放；
4. 如果 |Sx| < |Sy| 或 |Sx| > |Sy|，则表示差值缩放；
5. 如果 |Sx| 或 |Sy| 等于 1，则表示图形在 X 轴方向或 Y 轴方向不变；
6. 如果 Sx 或 Sy 小于零，则表示图形在 X 轴方向或 Y 轴方向作**镜面变换**。

### 2D 矩阵表示

对于平移、旋转和缩放变换，每个基本的变换都可表示为通用矩阵形式：
$$
P' = M1 \cdot P + M2

\\

P’、P 表示变换前后两个点的坐标的列向量。\\

M1 是一个包含乘法系数的 2×2 矩阵。\\

M2 是一个包含平移项的两元素列矩阵。
$$
**齐次坐标**表示：基本思想是把一个 n 维空间的几何问题转换到 n+1 维空间中去。

例如：二维空间中点的坐标(x, y)的齐次坐标表示为(h\*x，h\*y，h)(h≠0的任意实数)。只要给定一个点的齐次坐标表示(xh，yh，h)，就能得到唯一的笛卡儿坐标(x, y)。其中 x=xh/h，y=yh/h。

一个笛卡儿坐标表示的点，用齐次坐标表示时，是无穷的（h 取值不同），但一个齐次坐标表示的点，用笛卡儿坐标表示时，是唯一的。

齐次坐标表示不是唯一的，**通常当 h=1 时，称为规格化齐次坐标**。用齐次坐标技术，可改写平移变换、缩放变换和旋转变换为统一的乘积形式。

规格化齐次坐标下的变换矩阵如下：

1. 平移变换

$$
P' = T(t_x, t_y) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$

2. 旋转变换（坐标原点为旋转中心）

$$
P' = R(\theta) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$

3. 缩放变换

$$
P' = S(S_x, S_y) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
S_x & 0 & 0 \\
0 & S_y & 0 \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$



### 复合变换

利用矩阵表示，就可通过计算单个变换的矩阵乘积，将任意顺序变换的矩阵建立为复合变换矩阵。

#### 连续平移

两个连续的平移向量(tx1, ty1)和(tx2, ty2)被用于点 P，那么最后的点坐标可计算为 
$$
P'
= T(tx2, ty2) · { T(tx1, ty1) · P }
= { T(tx2, ty2) · T(tx1, ty1) } · P
$$
计算时，可先计算两个平移变换矩阵的乘积。
$$
T(tx2, ty2) · T(tx1, ty1) = T(tx2 + tx1, ty2+ ty1)
$$
连续平移是可加的。

#### 连续旋转

应用于点 P 的两个连续旋转，得到的点P'的坐标可计算为 
$$
P' = R(θ2) · { R(θ1) · P } = {R(θ2) · R(θ1)} · P
\\
R(θ2) · R(θ1)= R(θ1+θ2)
$$
则P’的坐标可计算为
$$
P' = R(θ1+θ2) · P
$$
连续旋转是可加的。

#### 连续缩放

两个连续缩放操作的变换矩阵连接，产生的复合变换矩阵：
$$
S(sx2, sy2) · S(sx1, sy1) = S(sx1· sx2, sy1· sy1)
$$
连续缩放操作是相乘的，非叠加的。

#### 通用基准点变换

1. **平移使基准点移动到坐标原点。**
2. **针对原点做指定变换。**
3. **反向平移使基准点回到原始位置。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123329996.png" alt="image-20251112123329996" style="zoom:60%;" />

#### 通用方向变换

1. **旋转对象使任意方向与坐标轴方向重合。**
2. **针对坐标轴方向做指定变换。**
3. **反向旋转使任意方向回到原方向。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123501361.png" alt="image-20251112123501361" style="zoom:50%;" />

#### 连接特性

$$
A*B*C = (A*B)*C = A*(B*C)
\\
A*B <> B*A
$$



### 复合二维变换

平移、旋转和放缩矩阵通常记为 T、R 和 S。

二维变换具有结合性：(AB)C=A(BC)。

二维变换不具有交换性，一个例子是如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123813026.png" alt="image-20251112123813026" style="zoom:55%;" />

两个特殊的二维变换：

1. 刚体变换

可以分解为：平移和旋转的组合。

物体的形状没有变化，位置和方位有变化。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123903470.png" alt="image-20251112123903470" style="zoom:67%;" />

2. 仿射变换

可以分解为：平移、旋转和放缩的组合。

保持点的共线性、长度的比例＝>平行线。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123909492.png" alt="image-20251112123909492" style="zoom:67%;" />

### 3D 几何变换

#### 3D 平移

$$
平移向量：t_x, t_y, t_z

\\

T = \begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 3D 缩放

$$
缩放因子：S_x, S_y, S_z

\\

T = \begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

针对给定点缩放（思路依旧是平移，然后按照原点缩放的方式，然后平移回去）：
$$
参数: s_x, s_y, s_z, (x_f, y_f, z_f)

\\

变换矩阵 M = T(x_f, y_f, z_f)S(s_x, s_y, s_z)T(-x_f,-y_f, -z_f)
$$

#### 3D 旋转

1. 绕 Z 轴旋转

绕 Z 轴旋转，Z 坐标不变，矩阵上只有 x, y 有因子。
$$
P' = R_z(\theta) \cdot P\\

R_z(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0\\
\sin\theta & \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

2. 绕 X 轴旋转

同理。
$$
P' = R_x(\theta) \cdot P\\

R_x(\theta) =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & \cos\theta & -\sin\theta & 0\\
0 & \sin\theta & \cos\theta & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

3. 绕 Y 轴旋转

同理。
$$
P' = R_y(\theta) \cdot P\\

R_y(\theta) =
\begin{bmatrix}
\cos\theta & 0 & \sin\theta & 0\\
0 & 1 & 0 & 0\\
-\sin\theta & 0 & \cos\theta & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### 3D 复合变换

一般 3D 物体旋转：

- 旋转轴平行于坐标轴。
- 旋转轴不平行于坐标轴。

1. 旋转轴平行于坐标轴之一。

- **平移使旋转轴与平行坐标轴重合。**
- **完成指定旋转。**
- **反向平移使回到原位置。**

2. 旋转轴不平行于任何坐标轴。

- **平移使旋转轴过原点。**
- **旋转使旋转轴与坐标轴之一重合。**
- **完成指定旋转。**
- **反向旋转。**
- **反向平移。**

下面我们需要细细分析一下这个过程。
$$
旋转轴由两个坐标点确定\\

P1(x1, y1, z1) -> P2(x2, y2, z2)\\

\\

旋转轴矢量\\

V = P2－P1 = (Vx, Vy, Vz)\\

\\

沿旋转轴的单位向量\\

u=V/|V| =(a, b, c)\\

a=(x2-x1)/|V|、b=(y2-y1)/|V|\\

c=(z2-z1)/|V|\\

|V| = sqrt(Vx2 + Vy2 + Vz2)
$$
<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191648140.png" alt="image-20251112191648140" style="zoom:55%;" />

#### 第一步

平移旋转轴矢量使其过原点。
$$
T_1 = \begin{bmatrix}
1 & 0 & 0 & -x_1 \\
0 & 1 & 0 & -y_1 \\
0 & 0 & 1 & -z_1 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$


#### 第二步

旋转物体使旋转轴与 z 轴重合。

这一步又分为两小步：

- 将向量 U 绕 x 轴旋转到 xz 平面上: Rx(α)。
- 将向量 U 绕 y 轴旋转到 z 轴上: Ry(β)。

第一小步，Rx(α)。

**计算 α 的关键点是利用旋转角等于在 Y-Z 平面里的投影来计算。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112192902539.png" alt="image-20251112192902539" style="zoom:55%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193020675.png" alt="image-20251112193020675" style="zoom:55%;" />
$$
R_x(\alpha) = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & c/d & -b/d & 0 \\
0 & b/d & c/d & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$
第二小步，Ry(β)。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193438032.png" alt="image-20251112193438032" style="zoom:55%;" />

注意在我们假想的正方向情境下，绕 y 轴旋转是顺时针，是负方向，所以 sin(β)=-a。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193451270.png" alt="image-20251112193451270" style="zoom:55%;" />
$$
R_y(\beta) = \begin{bmatrix}
d & 0 & -a & 0 \\
0 & 1 & 0 & 0 \\
a & 0 & d & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 第三步

完成指定旋转 Rz(θ)。
$$
R_z(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0\\
\sin\theta & \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 第四步

反向旋转使旋转轴回到原始方向。
$$
R_y(-β)= R_y^{-1}(β)
\\
R_x(-α)= R_x^{-1}(α)
$$

#### 第五步

反向平移使旋转轴回到原始位置。
$$
T_2 = \begin{bmatrix}
1 & 0 & 0 & x_1 \\
0 & 1 & 0 & y_1 \\
0 & 0 & 1 &z_1 \\
0 & 0 & 0 & 1
\end{bmatrix} = T_1^{-1}
$$
整个过程的流程图如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191212935.png" alt="image-20251112191212935" style="zoom:55%;" />

### 三维变换

三维变换可以看作是**对照相过程的模拟**，即如何将场景中的三维几何物体变换到二维屏幕上。

场景造型：

- 场景坐标系：世界坐标系、局部坐标系。
- 变换：造型变换。

放置虚拟照相机

- 坐标系：视点坐标系（虚拟照相机的位置、朝向以及向上的方向）。
- 变换：取景变换（在视域四棱锥进行裁剪和背面剔除）。

投影(照相、摄影)

- 坐标系：投影坐标系和窗口坐标系。
- 变换：投影变换。

二维显示

- 坐标系：窗口坐标系、规格化设备坐标系与屏幕的物理坐标系。
- 变换：设备变换、视窗变换。

#### 三维变换流程图（牢记）

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112195236840.png" alt="image-20251112195236840" style="zoom:50%;" />

# 第十二章 OpenGL 编程基础

## 10 中基本图元模型

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192540046.png" alt="image-20251111192540046" style="zoom:55%;" />

## 程序的基本结构

一段实例代码如下：

```cpp
#include <windows.h>
#include <gl/gl.h>
#include <gl/glu.h>
#include <gl/glaux.h>
#include <stdio.h>


void myinit(void);
void CALLBACK myReshape(int w, int h);
void CALLBACK display(void);


void myinit(void)
{                                     // 初始化
    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色
}
void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor4f(0.2, 0.8, 1.0, 1.0); // 选颜色(R,G,B)
    glRotatef(30, 1.0, 1.0, 0.0);  // 做旋转变换
    auxWireCube(1.0);              // 绘制六面体的虚线图
    glFlush();                     // 强制绘图，不驻留缓存
     
}

void CALLBACK myReshape(int w, int h)
// 用于窗口大小改变时的处理，与绘图无关
{
    glViewport(0, 0, w, h);
}


void main(void)
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA); // 窗口显示单缓存和彩色模式
    auxInitPosition(0, 0, 200, 200);           // 屏幕左上点及大小
    auxInitWindow("openglsample.c");           // 初始化窗口，标题
    myinit();
    auxReshapeFunc(myReshape);
    auxMainLoop(display);
}
```

绘制效果如图：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192641692.png" alt="image-20251111192641692" style="zoom:55%;" />

代码中需要注意以下几点：

1. 头文件使用

若应用程序使用 OpenGL 核心函数，应包括头文件 <gl/gl.h>。

使用 GLU 库函数，应包括头文件 <gl/glu.h>。

使用 AUX 库函数，应包括头文件 <gl/glaux.h>。

使用 WGL 和 Win32 应包括头文件 <windows.h>。

2. 程序的基本结构

（1）定义窗口

Windows 下的 OpenGL 实现提供了一个辅助函数库 aux，用于解决开窗口和处理输入事件等问题

窗口管理函数：

```cpp
void auxInitDisplayMode(Glbitfield mask); // 函数定义窗口的特性，如颜色和缓存区的性质。

// 窗口显示单缓存和 RGB(彩色)模式。
// auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);

void auxInitPosition(Glint x, Glint y, Glint width, Glint height); // 定义窗口在屏幕上的位置和大小。

void auxInitWindow(Glbyte *titleString) // 打开窗口。窗口的标题为字符串 titleString。窗口把 ESC 键与退出函数联系起来，可以用来关闭窗口，退出程序。
```

处理输入事件:

当改变窗口尺寸、移动窗口、重新显示窗口时，由 auxReshapeFunc(myReshape) 调用函数 myReshape 重新定义窗口属性。通常 myReshape 函数调用 glViewPort 函数，对当前图形进行裁剪，重新定义投影矩阵等。

OpenGL 辅助函数库中还包括处理键盘和鼠标输入事件的函数。

（2）初始化操作

由于 OpenGL 的绘图方式是由一系列的状态确定的，因而在绘制图形前需要做一些准备工作，包括清缓存区、定义光照模型、纹理映射等基本操作的初始化状态、设置三维视景体、定义视口。 

例如：

```cpp
glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色。

glClear(GL_COLOR_BUFFER_BIT); // 将颜色缓存清为 glClearColor 命令所设置的颜色，即背景色。
```

（3）设置观察坐标系下的取景模式和取景框位置及大小，主要利用了三个函数：

```cpp
// 设置屏幕上视口大小。(x, y)指定视口左下角在窗口坐标系中的位置，width 和 height 分别确定矩形视口宽和高，均以像素为单位。注意：视口的大小和尺寸是在窗口坐标系中进行度量的，默认状态下其坐标原点位于窗口的左下角，其尺寸与窗口的大小相同。
void glViewport(GLint x, Glint y, Glsizei width, Glsizei height);

// 设置投影方式为正交投影（平行投影），其取景体积是一个各面均为矩形的六面体，在默认状态为平行正交投影。
void glOrtho(left, right, bottom, top, near, far);

// 设置投影方式为透视投影，其取景体积是一个截头锥体。
// 它通过指定 x-z 平面内的视角大小及宽高比来确定沿视线方向的棱锥，并通过指定远、近剪切面与视点间的距离来截断棱锥，得到观察体。
void gluPerspective(fovy, aspect, zNear, zFar);
```

（4）使用 OpenGL 的库函数构造几何物体对象的数学描述，包括点线面的位置和拓扑关系、几何变换、光照处理等，这是 OpenGL 程序的主要部分。

（5）程序的微机运行环境配置

程序中除了包含必需的头文件如 <windows.h> <gl/gl.h> <gl/glaux.h> <gl/glu.h> 外。在创建执行文件时，在 VC 环境设置中要链接 opengl32.lib, glu32.lib 和 glaux.lib 三个函数库。运行已创建的执行文件时，在 windows\system 目录下要有 opengl32.dll，glu32.dll 两个动态连接库。

## 基本绘制单元

要绘制某个几何对象，必须指明究竟是哪种类型的几何对象（例如点、线和多边形）。

OpenGL 绘制部分的代码结构类似于代码分段的形式：

```cpp
glBegin(mode);

	...

    glVertex3f(x,y,z);
    glVertex3f(x,y,z);
    glVertex3f(x,y,z);

	...

glEnd();
```

### 点的绘制

OpenGL 中点定义为一个方块，在默认状态下，点是屏幕上的一个像素。在 OpenGL 中，一个点是当作一个 n（2,3,4）维向量来处理的。

例如在屏幕上绘制三个点：

```cpp
glBegin(GL_POINTS)
    glVertex3f(1.0, 0.0, 0.0);
    glVertex3f(1.0, 1.0, 0.0);
    glVertex3f(0.0, 1.0, 1.0);
glEnd();
```

### 线的绘制

与数学意义上两端无限延伸的直线不同，OpenGL的线是数学定义中的线段，用**成对的端点**来描述。

```cpp
// 一条由坐标原点到点（1.0,1.0）的线段。
glBegin(GL_LINES)
    glVertex2f(0.0, 0.0);
    glVertex2f(1.0, 1.0);
glEnd()；
```

### 多边形的绘制

多边形指封闭线段围成的区域。但 OpenGL 中可以描述的多边形有两点限制：多边形的边除了多边形的顶点外不允许相交，即确保多边形为**简单多边形**；多边形为**凸多边形**，即任给多边形的两个内部点，其连线完全在多边形内。

```cpp
// 其中，* 表示 glVertex 函数的上述任一种组合形式，由多边形顶点 v0,v1,…,vn 的表示形式而定。注意：多边形顶点应按一定顺序排列（如逆时针）。
glBegin(GL_POLYGON);
    glVertex*(v0);
    glVertex*(v1);
    ...
    glVertex*(vn);
glEnd();
```

### 矩形的绘制

用的比较频繁，OpenGL 专门设置了绘制矩形的函数。

```cpp
// 矩阵的左上、右下角点坐标分别为（x1,y1）和(x2,y2)，或者用数组指针 v1、v2 表示。用上述函数描述的矩形位于 z=0 平面内，并且各边分别平行于 x、y 轴。但注意：经过坐标变换之后，这些特性可能改变。 
void glRect{dfis}(TYPE x1, TYPE y1, TYPE x2, TYPE y2);
void glRect{dfis} v(TYPE *v1, TYPE *v2);
```

## 例 10.2

```cpp
void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor4f(1.0, 1.0, 1.0, 1.0); // 选颜色(R,G,B)
    glPointSize(6.0);                // 设置点的大小

glBegin(GL_POINTS);              // 在屏幕上绘制三个点
    glVertex3f(0.1, 0.2, 0.0);
    glVertex3f(0.2, 0.7, 0.0);
    glVertex3f(0.5, 0.8, 0.0);
glEnd();

glBegin(GL_LINES); // 在屏幕上绘制一条线段
    glVertex2f(0.0, 0.4);
    glVertex2f(-0.3, 0.8);
glEnd();

glBegin(GL_POLYGON); // 在屏幕上绘制一个四边形
    glVertex2f(-0.6, 0.0);
    glVertex2f(-0.4, 0.0);
    glVertex2f(-0.4, 0.3);
    glVertex2f(-0.6, 0.4);
glEnd();

    glColor3f(1.0, 0.0, 0.0);    // 设置当前颜色为红色
    glColor3f(0.0, 0.0, 1.0);    // 设置当前颜色为蓝色
    glRectf(0.5, 0.5, 0.7, 0.7); // 绘制一个矩形
    glColor3f(0.0, 1.0, 0.0);    // 设置当前颜色为绿色
    glRectf(0.8, 0.8, 0.9, 0.9); // 绘制一个矩形
    glRectf(0.2, 0.2, 0.4, 0.4); // 绘制一个矩形
   	glFlush();                  // 强制绘图，不驻留缓存
}
```

最终绘制效果如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200407898.png" alt="image-20251111200407898" style="zoom:70%;" />

## 坐标变换

在二维平面上创建三维物体的过程：在三维空间中创建所绘制物体的模型，由计算机经过适当的变换，将三维坐标系中的点转换为屏幕上的相应位置，以得到理想的视觉效果。

OpenGL 就是实现将物体的各个顶点通过各种变换矩阵的作用映射到屏幕的过程。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200529792.png" alt="image-20251111200529792" style="zoom:50%;" />

（1）通用的矩阵操作命令

```cpp
// 参数取值：GL_MODELVIEW、GL_PROJECTION或GL_TEXTURE
// 默认的选定矩阵为 GL_MODELVIEW 变换矩阵。
void glMatrixMode(Glenum mode);

// OpenGL 中的变换命令都是对当前矩阵进行操作，因此在选定可修改矩阵后，应首先用上述命令设置当前操作矩阵为单位矩阵。
void glLoadIdentity(void);
```

（2）模型观察变换

模型观察变换过程就是一个将顶点坐标从世界坐标变换到视觉坐标的过程。

世界坐标系是一个右手坐标系，是固定不变的，在初始态下，其 x 轴为沿屏幕水平向右，y 轴为沿屏幕垂直向上，z 轴则为垂直屏幕面向外指向用户

观察坐标系是一个左手坐标系，是可以活动的。在初始态下，原点及 x、y 轴分别与世界坐标系的原点及 x、y 轴重合，而 z 轴则正好相反，即为垂直屏幕面向内。

在初始状态下，相机在观察坐标系的原点且指向z轴正向，即为垂直屏幕面向内。

```cpp
// 平移变换。
void glTanslate{fd}(TYPE x, TYPE y, TYPE z);

// 旋转变换。
// 绕矢量 v = (x, y, z)T 逆时针方向旋转 angle 指定的角度。旋转角度的范围是 0 ~ 360 度。
void glRotate{fd}(TYPE angle, TYPE x, TYPE y, TYPE z);

// 缩放变换。
void glScale{fd}(TYPE x, TYPE y, TYPE z);
```

变换的顺序：

```cpp
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMultMatrixf(N); /* apply transformation N */
glMultMatrixf(M); /* apply transformation M */
glMultMatrixf(L); /* apply transformation L */
glBegin(GL_POINTS);
glVertex3f(v); /* draw transformed vertex v */
glEnd();

// 在这个过程中，在 GL_MODELVIEW 状态下，相继引入了 I（单位阵），N，M，L 矩阵。

// 变换后的顶点为 NMLv(顶点取列向量)。

// 顶点的变换为 N(M(Lv))，即是先作变换 L，然后是变换 M，最后才是 N。

// 顶点 v 的实际变换顺序正好与指定的顺序相反。
```

（3）投影变换

在调用投影变换命令前必须先在程序中加入下述语句：

```cpp
glMatrixMode(GL_PROJECTION);

glLoadIdentity();
```

这两条命令一方面指定接下来的变换命令只影响投影矩阵，同时也将当前投影矩阵设置为单位阵。

一些函数：

```cpp
// 透视投影。
void gluPerspective(Gldouble fovy, Gldouble aspect, Gldouble zNear, Gldouble zFar);

// 正交投影。
void glOrtho(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top, Gldouble near, Gldouble far);

// 对于二维图形向二维屏幕的投影，则应使用实用库中的如下函数：
// 前面提到过，用二维顶点命令绘制的二维物体的 z 坐标均为零，而 gluOrtho2D() 命令假定场景中的 z 坐标介于 -1.0 和 1.0 之间。
void gluOrtho2D(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top);
```

（4）视口变换

```cpp
// 注意：应该使视口的长宽比与取景体积的长宽比相等，否则会使图像变形。
void glViewport(GLint x, Glint y, Glsizei width, Glsizei height);
```

## 例 10.3

绘制三维空间绘制立方体的程序。

```cpp
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>
#include <stdio.h>


void myinit(void);
void CALLBACK myReshape(int w, int h);
void CALLBACK display(void);


// 初始化
void myinit(void)
{
    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色
    glShadeModel(GL_FLAT);            // 常量明暗处理方式
}

void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor3f(1.0, 1.0, 1.0); // 选当前颜色(R,G,B)为白色
    glLoadIdentity();         // 设置当前矩阵为单位矩阵

    glTranslatef(0.0, 0.0, -3.0); // 平移变换
    glRotatef(45, 1.0, 1.0, 0.0); // 旋转变换
    glScalef(1.0, 2.0, 1.0);      // 缩放变换
    auxWireCube(1.0);             // 绘制立方体
    glFlush();                    // 强制绘图，不驻留缓存
}

void CALLBACK myReshape(int w, int h) // 用于窗口改变大小时的处理，与绘图无关
{
    glMatrixMode(GL_PROJECTION);                              // 指明当前矩阵操作是针对投影矩阵进行的
    glLoadIdentity();                                         // 设置当前矩阵为单位矩阵
    gluPerspective(70.0, (GLfloat)w / (GLfloat)h, 1.5, 40.0); // 投影变换
    glMatrixMode(GL_MODELVIEW);                               // 返回视点-模型矩阵
    glViewport(0, 0, w, h);                                   // 定义视口变换
}


void main(void)
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    // 窗口显示单缓存和RGB(彩色)模式
    auxInitPosition(0, 0, 200, 200);          // 大小 x=200、y=200 ， (0,0)是屏幕左上点
    auxInitWindow(“Perspective 3 - D Cubes”); // 初始化窗口，参数是标题
    myinit();
    auxReshapeFunc(myReshape);
    auxMainLoop(display);
}
```

最终绘制效果如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201527191.png" alt="image-20251111201527191" style="zoom:60%;" />

## OpenGL 状态管理

OpenGL 是一个状态机，应用程序通过 OpenGL 函数调用来实现状态的设置。

OpenGL 的绘图方式是由一系列的状态决定的，如果设置了一种状态或模式而不改变它，OpenGL 在绘图过程中将一直保持这种状态或模式。

OpenGL 总是按照应用程序的发送顺序执行命令。状态影响应该是最接近绘制的状态改变函数来决定。注意：状态改变影响效率。

## 考试参考

### 实例二

画一个三角形和一个正方形。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201944028.png" alt="image-20251111201944028" style="zoom:55%;" />

```cpp
int DrawGLScene(GLvoid)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    glTranslatef(-1.5f, 0.0f, -6.0f);
    glBegin(GL_TRIANGLES);          // 绘制三角形
    glVertex3f(0.0f, 1.0f, 0.0f);   // 上顶点
    glVertex3f(-1.0f, -1.0f, 0.0f); // 左下
    glVertex3f(1.0f, -1.0f, 0.0f);  // 右下
    glEnd();                        // 三角形绘制结束

    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位
    glBegin(GL_QUADS);              // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上
    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下
    glEnd();                        // 正方形绘制结束

    return TRUE;
}
```

### 实例三

着色。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111202057148.png" alt="image-20251111202057148" style="zoom:55%;" />

```cpp
int DrawGLScene(GLvoid)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glTranslatef(-1.5f, 0.0f, -6.0f);
    glBegin(GL_TRIANGLES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex3f(0.0f, 1.0f, 0.0f);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, 0.0f);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex3f(1.0f, -1.0f, 0.0f);
    glEnd();

    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位
    glColor3f(0.5f, 0.5f, 1.0f);    // 一次性将当前色设置为蓝色
    glBegin(GL_QUADS);              // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上
    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下
    glEnd();                        // 正方形绘制结束

    return TRUE;
}
```

### 实例四

### 实例五

