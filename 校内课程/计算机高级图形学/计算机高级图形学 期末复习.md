---
title: 计算机高级图形学 期末复习
categories:
  - 校内课程
  - 计算机高级图形学
abbrlink: 1b712153
date: 2025-11-04 21:40:00
updated: 2025-11-13 20:45:00
---

<meta name="referrer" content="no-referrer"/>

# 第一章 绪论

## 本章复习重点

- 图形学和图像学的区别。
- 走样的原因和反走样的概念。
- 选择题（直线算法）。
- 光栅显示系统。

<!-- more -->

## 计算机图形学概述

|          | 图形处理                                                     | 图像处理                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据来源 | **多来源于主观世界，人为地由计算机产生，由数据描述而生成图形。** | **多来源于客观世界，来自对实物的拍摄、捡取。**               |
| 处理方法 | 图形处理技术包括：几何变换，拟合，图形操作，图形模型产生，图形处理，隐藏线，面的消除，浓淡处理，色彩纹理处理，图案生成等。 | 图像处理技术包括：图像几何修正（校正），图像采集、存储、编码、滤波、增强、压缩、复原、重建、图形理解识别等。 |
| 理论基础 | 多利用数学矩阵代数、计算几何、分形几何等。                   | 多利用二维数字信号滤波，各种信号正交变换等。                 |
| 应用领域 | 多应用 CAD/CAM/CAE/CAI 等领域，以及计算机艺术、计算机模拟、计算机动画、多媒体系统应用等。 | 多应用于多媒体系统，医学，遥感遥测，工业控制，监测监视，天文气象，军事侦察等。 |

## 图形学研究内容

1. 建模：创建用计算机表示的三维物体模型，主要是形状表述与定义。
2. 渲染：通过各种矩阵变换从模型产生物体的二维图像，主要考虑光照、透视变换。
3. 动画：描述物体运动变化。

## 光栅扫描系统

### 随机扫描与光栅扫描

随机扫描技术的本质是按照显示命令的任意顺序，将电子束从一个端点偏转到另一个端点。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203112346.png" alt="image-20251104203112346" style="zoom:50%;" />

光栅图形具有对显示区域填充颜色或图案的能力，存储的图像更加易于操作。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203145253.png" alt="image-20251104203145253" style="zoom:60%;" />

光栅显示器上的图形由光栅（raster）形成。

**光栅是一组互相平行的水平扫描线。每行扫描线是由大小一致的显示单元组成的显示序列，每一显示单元称为一个像素，可显示给定的颜色和灰度。**

光栅显示器将显示图元（primitive）如线、文字、填充颜色或图案区域等，以像素的形式存储到一个刷新缓冲器中。

### 光栅扫描系统

构成：

1. 帧缓冲区（Frame Buffer）。
2. 视频控制器（Video Controller）。
3. 显示处理器（Display Processor / GPU）。

视频控制器如何实现基本刷新：

1. 有两个寄存器用来存放屏幕像素的坐标。
2. 存储在帧缓冲区中该像素对应位置的值被取出，并用来设置 CRT 电子束的强度值。

显示处理器的主要任务是**将应用程序给出的图形定义数字化为一组像素强度值，并存放在帧缓冲区中**。这个数字化过程称为**扫描转换（Scan Conversion）**。

### 直线段的扫描转换算法

当我们对直线进行光栅化时，需要在显示器有限个像素中，确定最佳逼近该直线的一组像素，并且按扫描线顺序，对这些像素进行写操作，这个过程称为用显示器绘制直线或直线的扫描转换。

三种算法：

1. 基本增量算法（DDA）数值微分算法。
2. 中点画线算法。
3. **Bresenham 算法（使用最广泛）。**

#### DDA 算法

在一个坐标轴上以单位间隔对线段取样，则另一个坐标轴以常数 m 或 1/m 变化，从而获得线段上各像素点。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104205009793.png" alt="image-20251104205009793" style="zoom:50%;" />

算法迭代公式：
$$
\text{若 } |m| \le 1:
\begin{cases}
x_{k+1} = x_k + 1, \quad y_{k+1} = y_k + m, & (x_a < x_b) \\
x_{k+1} = x_k - 1, \quad y_{k+1} = y_k - m, & (x_a > x_b)
\end{cases}

\\

\text{若 } |m| \ge 1:
\begin{cases}
y_{k+1} = y_k + 1, \quad x_{k+1} = x_k + \dfrac{1}{m}, & (y_a < y_b) \\
y_{k+1} = y_k - 1, \quad x_{k+1} = x_k - \dfrac{1}{m}, & (y_a > y_b)
\end{cases}
$$

#### Bresenham 算法

**只用整数计算寻找最接近实际直线的整数坐标。即从 Yk 和 Yk + 1 中取出最贴近 y 坐标的点作为拟合点，但只通过整数计算。**

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104211634765.png" alt="image-20251104211634765" style="zoom:50%;" />

推导过程如下：
$$
\\
\textbf{假定：} \quad 0 < m < 1
\\

已知点 (x_k, y_k)，求下一点 (x_{k+1}, y_{k+1})。(x_{k+1}, y_{k+1}) 的两种可能为：(x_{k+1}, y_k) \quad \text{或} \quad (x_{k+1}, y_k + 1)。其中：x_{k+1} = x_k + 1
\\

\textbf{推导：}
\\
设两点与理想直线的距离分别为 d_1、d_2：

\\
\begin{aligned}
d_1 &= y - y_k = m x_{k+1} + b - y_k, \\
d_2 &= y_{k+1} - y = y_{k+1} - (m x_{k+1} + b).
\end{aligned}
\\
因此：d_1 - d_2 = 2m x_{k+1} - 2y_k + 2b - 1
\\
令：m = \frac{\Delta y}{\Delta x}
\\
代入上式，引入决策参数 P_k 表示相对距离：
\\
P_k = \Delta x (d_1 - d_2) = 2\Delta y x_k - 2\Delta x y_k + C
\\
其中：C = 2\Delta y + \Delta x (2b - 1)
\\

\textbf{推论：}
\\
\begin{cases}
P_k < 0, & \text{则选择 } y_{k+1} = y_k \\
P_k \ge 0, & \text{则选择 } y_{k+1} = y_k + 1
\end{cases}
\\

P_k 的递推公式：
\\

由
\\
\begin{aligned}
P_{k+1} &= 2\Delta y x_{k+1} - 2\Delta x y_{k+1} + C, \\
P_k &= 2\Delta y x_k - 2\Delta x y_k + C,
\end{aligned}
\\

两式相减得：
\\
P_{k+1} - P_k = 2\Delta y (x_{k+1} - x_k) - 2\Delta x (y_{k+1} - y_k)
\\ = 2\Delta y - 2\Delta x (y_{k+1} - y_k)

\\
\therefore \; {P_{k+1}} \text{ 的递推公式：}
\\

P_{k+1} =
\begin{cases}
P_k + 2\Delta y, & (P_k < 0) \\[6pt]
P_k + 2\Delta y - 2\Delta x, & (P_k \ge 0)
\end{cases}
\\

初始值为：\\

P_0 = 2\Delta y - \Delta x
$$

#### 中点画线算法

用判别式判断点与直线的关系。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213004956.png" alt="image-20251104213004956" style="zoom:50%;" />

算法思路：
$$
F(x, y) = (m x + b) - y \\[6pt]
F(x_{k+1},\, y_k + 0.5) = 0, 
\quad \text{对应点 } (x_{k+1},\, y_{k+1}) \text{ 可能为 } (x_{k+1},\, y_k + 1) \text{ 或 } (x_{k+1},\, y_k) \\[6pt]
\begin{cases}
F(x_{k+1},\, y_k + 0.5) < 0, & \text{中点在直线上方，选择 } (x_{k+1},\, y_k) \\[6pt]
F(x_{k+1},\, y_k + 0.5) > 0, & \text{中点在直线下方，选择 } (x_{k+1},\, y_k + 1)
\end{cases}
$$

### 走样与反走样

对于光栅系统来说，只能用光栅网格上的像素近似地描绘平滑的直线、多边形和圆、椭圆等曲线图元。如果引起了图中看到的**锯齿状或阶梯状的边界线问题**，在图形学中称为“走样”。

用于减少或消除这种现象的技术称为“反走样”。

<img src="https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213414197.png" alt="image-20251104213414197" style="zoom:67%;" />

# 第二章 颜色模型

## 本章复习重点

- 什么是设备无关的颜色模型。
- 什么是设备相关的颜色模型。
- RGB 和 CMY 颜色模型的比较。
- 哪些颜色模型是设备相关的？哪些颜色模型是设备无关的？
- 颜色模型之前的转换。

## 颜色模型

颜色模型就是用一组数值来描述颜色的数学模型。

**设备无关**的颜色模型：这类颜色模型是基于人眼对色彩感知的度量建立的数学模型，这些颜色模型主要用于计算和测量。

**设备相关**的颜色模型：以最常见的 RGB 模型为例，一组确定的 RGB 数值，在一个 LED 屏上显示，最终会作用到三色 LED 的电压上。这样一组值在不同设备上解释时，得到的颜色可能并不相同。

颜色模型是某个三维空间中的一个可见光子集。**任何一个色彩域都只是可见光的子集，任何一个颜色模型都无法包含所有的可见光。**

**三原色：红、绿、蓝。**

## RGB 颜色模型

三维直角坐标颜色系统中的一个单位正方体。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185701763.png" alt="image-20251109185701763" style="zoom:75%;" />

RGB 颜色模型构成的颜色空间是 CIE 原色空间的一个真子集。RGB 三原色是**加性原色**。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185942413.png" alt="image-20251109185942413" style="zoom:66%;" />

RGB 颜色模型通常用于彩色阴极射线管和彩色光栅图形显示器。

## CMY 颜色模型

**CMY 颜色模型是以红、绿、蓝三色的补色青（Cyan）、品红（Magenta）、黄（Yellow）为原色构成的颜色模型。**

CMY 颜色模型常用于**从白光中滤去某种颜色**，故称为**减色原色**空间。

![image-20251109185958804](https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185958804.png)

CMY 颜色模型对应的直角坐标系的子空间与 RGB 颜色模型对应的子空间几乎完全相同。

## RGB 和 CMY 颜色模型的对比

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190252186.png" alt="image-20251109190252186" style="zoom:60%;" />

## HSV 颜色模型

HSV 颜色模型是面向用户的。在 HSV 颜色模型中，每一种颜色和它的补色相差 180 度。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190711853.png" alt="image-20251109190711853" style="zoom:80%;" />

HSV 颜色模型的优点：

- 符合人眼对颜色的感觉。
- 当采用 RGB（或者 CMY）颜色模型时，改变某一颜色的属性，比如改变色调就必须同时改变 R、G、B（或者 C、M、Y）三个坐标；而采用 HSV 颜色模型时**只需改变 H 坐标**。即它的三个坐标是独立的。
- HSV 颜色模型构成的是一个**均匀**的颜色空间，采用线性的标尺，彩色之间感觉上的距离与 HSV 颜色模型坐标上点的欧几里德距离成正比。

## CIE（国际照明委员会）颜色模型

CIE 颜色模型包括一系列颜色模型，这些颜色模型是由国际照明委员会提出的，是**基于人的眼睛对 RGB 的反应，被用于精确表示对色彩的接收**。

CIE 是**设备无关性**：

- 被用来定义所谓的**独立于设备**的颜色。
- 它能够在任何类型的设备上产生真实的颜色，例如：扫描仪、监视器和打印机。
- 很适合计算机描述颜色的范围。

### CIE XYZ

XYZ 三刺激值的概念是以色视觉的三元理论为根据的，它说明**人眼具有接受三原色(红、绿、蓝)的接受器**，而所有的颜色均被视作该三原色的混合色。

CIE 制定了一种配色函数，能和 RGB 通过矩阵运算进行转化。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191400975.png" alt="image-20251109191400975" style="zoom:40%;" />

**颜色的概念可以分为两部分：亮度（光的振幅，即明暗程度）、色度（光的波长组合，即具体某种颜色）。**我们将光的亮度 Y 变量分离出来，之后用比例来表示三色刺激值：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191459184.png" alt="image-20251109191459184" style="zoom:60%;" />

可以发现，r、g、b 三者和为 1，只要知道其中两个就能求出另外一个。然后再和光的亮度 Y 结合起来，就能绘制 Yxy 颜色空间。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191806008.png" alt="image-20251109191806008" style="zoom:50%;" />

### CIE L\*a\*b\*

L\*a\*b\* 颜色空间是在 1976 年制定的，它是 CIE XYZ 颜色模型的改进型，以便**克服 Yxy 颜色空间存在的在 x、y 色度图上相等的距离并不相当于所觉察到的相等色差的问题**。同样是一种描述人类视觉感知的、设备无关的颜色模型。

L\*a\*b\* 的概念图：

- L：明亮度。
- a：从绿色到红色。
- b：从蓝色到黄色。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109192447257.png" alt="image-20251109192447257" style="zoom:50%;" />

与 XYZ 比较，CIE L\*a\*b\* 颜色更适合人眼的感觉。

利用 CIE L\*a\*b\*，颜色的亮度（L）、灰阶和饱和度（a、b）可以单独修正，这样，图像的整个颜色都可以在不改变图像或其亮度的情况下，发生改变。

## YUV

“Y” 表示明亮度（Luminance），“U” 和 “V” 分别表示色度（Chrominance）和浓度（Chroma)。

**采用 YUV 颜色空间的重要性是它的亮度信号 Y 和色度信号 U、V 是分离的。**这样能解决彩色电视机和黑白电视机的兼容问题，使黑白电视机也能接收到彩色信号。如果只有 Y 信号分量而没有 U、V 分量，那么这样表示的图就是黑白灰度图。

## 各种颜色模型之间的转换

各种颜色模型之间的转换一般是以 RGB 和 CIE XYZ 作为桥梁进行的。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193132489.png" alt="image-20251109193132489" style="zoom:50%;" />

### RGB 和 CMY

RGB 的取值通常是 0 ~ 255 的整数。

```markdown
C = 255 – R
M = 255 – G
Y = 255 – B
```

### RGB 和 HSV

1. 查表法

最可靠方法：

把 RGB 坐标转换为 1931 CIE XYZ 系统中的 (x， y， Y) 坐标。根据 (x， y， Y) 查找对应表，得到相应的 (H， S， V) 坐标。逆向操作则可以从 HSV 坐标转换到 RGB 坐标。

xyY 坐标与 HSV 坐标的对照表已由色度学实验得到。这种方法需要依赖对照表，比较笨重。

2. 数学公式

从 RGB 到 HSV：

设 m=max(r, g, b)，n=min(r, g, b)。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193605016.png" alt="image-20251109193605016" style="zoom:80%;" />

从 HSV 到 RGB：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193725839.png" alt="image-20251109193725839" style="zoom:50%;" />

### RGB 和 CIE XYZ

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193801097.png" alt="image-20251109193801097" style="zoom:67%;" />

### CIE XYZ 和 CIE L\*a\*b\*

L 的范围是 0 ~ 100，a, b 的范围是 -300 ~ 300。从 -a 到 +a 表示绿到红过渡，-b 到 +b 表示蓝到黄过渡。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193926183.png" alt="image-20251109193926183" style="zoom:77%;" />

### RGB 和 CIE YUV

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193949447.png" alt="image-20251109193949447" style="zoom:80%;" />

# 第三章 物体表示

## 本章复习重点

- 什么是建模坐标系，和世界坐标系的区别。
- OBJ 数据结构。
- 什么是 BREP，其结构中包含哪些信息。
- 半边数据结构。
- 多边形的优缺点。
- Bézier 曲线优缺点。
- NURBS 曲线和 B 样条曲线的改进是什么。
- 参数曲线的优缺点。
- 细分曲面的作用。
- 细分曲面的原理。
- Catmull-Clark subdivision。
- 有哪些常见的细分规则。
- 细分曲面的翼边存储。
- 物体的 CSG 表示。
- 什么是分形几何。
- 分型维数计算。
- L- 系统，能够用 L- 系统绘制物体。

## 物体的集合表示

### 坐标表示

一些概念：

1. 世界坐标系(WC)：场景参照坐标系，一个场景只有一个世界坐标系。
2. 观察坐标系(VC)：根据场景观察时的视点和观察方向所建立的坐标系。
3. 投影坐标(PC)：观察坐标系下场景的二维投影坐标。
4. 设备坐标系(DC)或屏幕坐标系：该场景的世界坐标系描述转换为一个或多个输出设备参照系来显示。该坐标系依赖于具体的显示输出设备。
5. 规范化坐标系(NC)：指独立于具体物理设备的一种坐标系，它的显示范围在 x 和 y 上都是 0 到 1，主要用于在计算机内部处理图形，对一个具体物理设备，NC 与 DC 仅仅是相差一个比例因子，NC可被看成是一个抽象的图形设备。 

在一个世界坐标系中，由许多物体组成。不同物理的几何描述和空间坐标系密切相关，在不同坐标系中有着不同的表示方式。**选择某个空间坐标系能使得该物体的几何表示最简单，这就是建模坐标系。**

例如，一个单位正方体在世界和建模坐标系中的不同表示如下。明显建模坐标系更简洁。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202426738.png" alt="image-20251109202426738" style="zoom:67%;" />

建模坐标系除了形式简洁，还方便几何操作。在同一几何场景中，一个物体可能会多次出现，它们可以通过复制加变换的方式得到：标准体素＋变换＝新的物体。

例如，以下是在建模和世界坐标系中旋转一个圆柱面。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202703686.png" alt="image-20251109202703686" style="zoom:60%;" />

### 多边形表示

物体的多边形表示是通过大量的平面片，三角形、四边形以及 n 边形。本质是**线性表示形式**。

#### 数据来源

一个物体经过三维测量和扫描以后，原始数据一般是三维空间中的点集。通过适当的重建算法得到其多边形的表示。

常用物体外形用数学表示方法包括参数曲面、细分曲面、隐式曲面等。

#### 表示方法：OBJ 格式

重点！！！

1. **顶点坐标表（x, y, z）：每个顶点处可能有多个平面片，一般情况下顶点数小于面片数。**
2. **纹理坐标表（u, v）：控制纹理映射时纹理在表面上的位置。**
3. **法向表 (nx, ny, nz) ：控制物体绘制时的着色光滑程度。如果顶点法向为取作该面片的法向，绘制出来的多边形物体棱角分明如果顶点法向是周围面片法向的某种平均，则绘制结果是光滑的。**
4. **面表：由指向顶点、纹理坐标以及法向的指针组成。**

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203355330.png" alt="image-20251109203355330" style="zoom:67%;" />

#### 数据结构

##### BRep 表示

**边界表示，也称为 BRep 表示**，它是几何造型中最成熟、无二义的表示法。**实体的边界通常是由面的并集来表示，而每个面又由它所在的曲面的定义加上其边界来表示，面的边界是边的并集，而边又是由点来表示的。**

在边界表示法中，边界表示按照**体－面－环－边－点**的层次，详细记录构成形体的所有几何元素的几何信息及其相互连接的拓朴关系。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203820619.png" alt="image-20251109203820619" style="zoom:60%;" />

1. 顶点：0 维度几何元素。
2. 边：一维几何元素。对正则形体，边是两邻面的交集，对非正则形体，边有可能是多个邻面的交集。边的形状可以是直线，也可以是曲线。
3. 环：二维几何元素。有序、有向边（直线段或曲线段）组成的面的封闭边界。外环边通常按逆时针方向排序，内环边通常按顺时针方向排序。
4. 面：二维几何元素。可以无内环，但必须有且只有一个外环。面有方向性，一般用其外法线方向作为该面的正向。面的形状可以是平面，也可以是曲面。
5. 体：三维几何元素。由封闭表面围成的空间，其边界是有限面的并集。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204101621.png" alt="image-20251109204101621" style="zoom:67%;" />

##### 半边数据结构

半边结构（Half-Edge Structure）：可定向的二维流形及其子集。

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204222651.png" alt="image-20251109204222651" style="zoom:55%;" />

每条边被记为两条半边，记录每条半边：

- 起始顶点的指针。
- 邻接面的指针(如果为边界，指针为 NULL)。
- 下一条半边(逆时针方向)。
- 相邻的半边。
- 前一条半边(可选)。

面：边界上的一条半边。

顶点：

- 坐标值。
- 指向以此顶点为起始端点的半边。

对于一个半边数据结构的简单形式，一个面仅仅需要储存一条围绕它的半边的指针。在半边数据结构中的点储存着 x，y，z 的位置和以其为起始点的半边的指针。

一个半边结构的实例：

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204623522.png" alt="image-20251109204623522" style="zoom:60%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204648499.png" alt="image-20251109204648499" style="zoom:60%;" />

半边结构的优势和不足：

- 优势：查询时间 O(1)， 操作时间 (通常) O(1)。
- 缺点：只能表示可定向流形，信息冗余。

#### 优势与不足

优势：

- 表示简单。
- 可以表示具有任意拓扑的物体。
- 可以表示具有丰富细节的物体。
- 大部分图形硬件支持多边形物体的加速绘制。

不足：

- 逼近表示，难以满足交互时放大要求。
- 难以用传统方法修改(编辑)物体外形。
- 缺乏解析表达式，几何属性计算困难。
- 在表示复杂拓扑和具有丰富细节的物体时，数据量庞大，建模、编辑、绘制、存储的负担重。

## 分形

普通几何学研究的对象，一般都具有整数的维数。比如，零维的点、一维的线、二维的面、三维的立体、乃至四维的时空。但是现实生活中象弯弯曲曲的海岸线这些对象就不能用传统欧几里德几何学的整数维描述或者说测量了。**要描述这一大类复杂无规的几何对象，就引入了分形理论，把维数视为分数维数。**这是几何学的新突破，引起了数学家和自然科学者的极大关注。

**分形的本意是不规则的、破碎的、分数的。是指以非整数维形式填充空间的形态特征。**分形几何通俗一点就是研究无限复杂但具有一定意义下的自相似图形和结构的几何学，基本思想是**客观事物具有自相似的层次结构，局部与整体在形态、功能、信息、时间、空间等方面具有统计意义上的相似性，称为自相似性**。

如何计算分型维数？

如果**某图形是由把原图缩小为 1/a 的相似的 b 个图形所组成**，有：
$$
a^D=b, D=logb/loga
$$
则指数 D 称为相似性维数，D 可以是整数，也可以是分数。

**分形体没有特征尺度，不能用一般测度即长度、面积、体积这类几何对象的特征量来表示**，只能用分形维数(Fractal dimension，也即“分维”)来度量，因而分维已成为描述无标度现象的特征参数。

分形树：以自然界中的丫字形树杈为生成元，将生成元在每一个层次上不断重复，会得到分形树。

分形树实现算法：递归算法、LS 文法、迭代函数系统算法。

<img src="https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095509626.png" alt="image-20251110095509626" style="zoom: 50%;" />

“递归”，这两个字用得十分好。递，即依次递变；归，即向一个方向归拢。“分形”，故名思议是指把一个形状细分为同样的形状。

分形几何的主要特征：

- 自相似性质：分形物体的任何一个部分都和物体整体具有某种程度的相似。
- 无限小细节性质：当无限地放大分形物体时，物体总是表现有细节，而不是像欧氏空间的物体一样最终会表现出光滑性。
- 维数非整数。

分形的自我相似，自我复制和自我嵌套用递归算法来实现是合适的，事实上经典分形图的绘制大多数可采用**递归算法**。一个很经典的例子就是 Koch 雪花曲线。

![image-20251110095853380](https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095853380.png)



计算 Koch 的分形维度。Koch 曲线是把一条直线缩小为 1/3 的相似的 4 个图形组成，根据定义是 log4/log3。

分形艺术的特点：

- 自相似性。
- 极小性。
- 嵌套性。
- 缠绕性。

# 第四章 图形渲染通道

## 本章复习重点

- 掌握图形渲染通道由那几个部分组成。
- 每一个功能点的作用。

## 渲染

渲染：通过几何物体生成真实可见图像的过程。

用点线面描述物体：

- 融合了数学表达。
- 物体集合的代表。

渲染物体：

- 渲染通道 render pass (Vulkan)。
- 渲染管线 rendering pipeline (OpenGL)。
  - 立即渲染模式（Immediate mode，也就是固定渲染管线）。
  - 核心模式(Core-profile, V 3.2)。

3D 渲染管线的三个阶段：

- 应用阶段：模型、数据读取、交互。
- 几何阶段。
- 光栅化阶段。

## 照相机模型

最通用的模式是**小孔成像模型**。所有捕捉到的光线都沿着指向焦点的路径到达，没有镜头变形（所有物体都处于焦点位置）。传感器响应与射线成比例。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111190809048.png" alt="image-20251111190809048" style="zoom:60%;" />

### 照相机参数

内参：在小孔成像模型中有一个光点P，其将光以直线的方式穿过纸板的小孔(光心），射到显示纸板（物理成像平面）上，其坐标系结构如下图所示。而内参的作用即是在知道P的x、y、z后可以求出x\`、y\`。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191053719.png" alt="image-20251111191053719" style="zoom:60%;" />

外参：假象你的头部就是三维世界的中心，相机、篮球都有一个坐标，但是现在要知道的是相机中照片中的篮球的一个点的位置，因此应该将以你头部为中心的世界转换为以相机焦点为中心的世界，这样不就更直观了么。所以第一步就是求外参矩阵，然后把 xw,yw,zw 转换为以相机为中心的世界中的坐标 xc,yc,zc。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191229526.png" alt="image-20251111191229526" style="zoom:60%;" />

第二步，就是小孔成像问题，将转换为相机为中心世界的 xw,yw,zw，利用相机内参转换为图片中的点的位置，在将图片中的点转换为是哪个像素（像素坐标）。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191302377.png" alt="image-20251111191302377" style="zoom:67%;" />

## 渲染通道

经典的 3D 渲染通道：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192044693.png" alt="image-20251111192044693" style="zoom:55%;" />

### 模型变换

将所有场景中的点 3D “世界”变换到世界坐标系。大小缩放、平移、旋转物体，**建模坐标系 -> 世界坐标系**。

### 光线模拟

光照参数：光源发散、表面反射、大气衰减、相机感应。

直接光照模型、全局光照模型。

### 视窗转换

旋转转换世界坐标系为相机坐标系。**世界坐标系 -> 视窗坐标系**。

### 裁剪

去掉视窗外的几何物体部分。

### 投影变换

应用透视原理。**视窗坐标系 -> 场景/图像坐标系**。

### 光栅化

转换图像坐标系为像素和颜色。

# 第五章 变换

## 本章复习重点

- 齐次坐标系及其作用。
- 二维平移，旋转、缩放矩阵。
- 理解模型变换、取景变换、投影变换、设备变换、视窗变换的作用。
- 一点透视、两点透视、三点透视。

## 几何（模型）变换

### 基本变换

#### 2D 平移

图形对象沿直线运动产生的变换。
$$
x' = x + t_x
\\
y' = y + t_y
\\
\\

P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

T = \begin{bmatrix}
t_x \\
t_y
\end{bmatrix}

\\
\begin{bmatrix}
x' \\
y'
\end{bmatrix}
=
\begin{bmatrix}
x \\
y
\end{bmatrix}
+
\begin{bmatrix}
t_x \\
t_y
\end{bmatrix}
\\

P' = P + T
$$

#### 2D 旋转

图形对象沿圆弧路径运动产生的变换。

基准点(pivot)，坐标原点或任意点。旋转角 θ。方向,约定：逆时针为正。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112104312207.png" alt="image-20251112104312207" style="zoom:67%;" />
$$
P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

R = \begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}

\\

\begin{bmatrix}
x' \\
y'
\end{bmatrix}

=

\begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{bmatrix}

\begin{bmatrix}
x \\
y
\end{bmatrix}

\\

P' = R \cdot P
$$


#### 2D 缩放

改变图形对象大小的变换。
$$
P = \begin{bmatrix}
x \\
y
\end{bmatrix}

P' = \begin{bmatrix}
x' \\
y'
\end{bmatrix}

S = \begin{bmatrix}
S_x & 0 \\
0 & S_y
\end{bmatrix}

\\

\begin{bmatrix}
x' \\
y'
\end{bmatrix}

=

\begin{bmatrix}
S_x & 0 \\
0 & S_y
\end{bmatrix}

\begin{bmatrix}
x \\
y
\end{bmatrix}

\\

P' = S \cdot P
$$
2D 缩放讨论：

1. 如果 |Sx| 或 |Sy| 大于 1，则表示图形在 X 轴方向或 Y 轴方向放大；
2. 如果 |Sx| 或 |Sy| 小于 1，则表示图形在 X 轴方向或 Y 轴方向缩小；
3. 如果 |Sx| = |Sy|，则表示均匀缩放；
4. 如果 |Sx| < |Sy| 或 |Sx| > |Sy|，则表示差值缩放；
5. 如果 |Sx| 或 |Sy| 等于 1，则表示图形在 X 轴方向或 Y 轴方向不变；
6. 如果 Sx 或 Sy 小于零，则表示图形在 X 轴方向或 Y 轴方向作**镜面变换**。

### 2D 矩阵表示

对于平移、旋转和缩放变换，每个基本的变换都可表示为通用矩阵形式：
$$
P' = M1 \cdot P + M2

\\

P’、P 表示变换前后两个点的坐标的列向量。\\

M1 是一个包含乘法系数的 2×2 矩阵。\\

M2 是一个包含平移项的两元素列矩阵。
$$
**齐次坐标**表示：基本思想是把一个 n 维空间的几何问题转换到 n+1 维空间中去。

例如：二维空间中点的坐标(x, y)的齐次坐标表示为(h\*x，h\*y，h)(h≠0的任意实数)。只要给定一个点的齐次坐标表示(xh，yh，h)，就能得到唯一的笛卡儿坐标(x, y)。其中 x=xh/h，y=yh/h。

一个笛卡儿坐标表示的点，用齐次坐标表示时，是无穷的（h 取值不同），但一个齐次坐标表示的点，用笛卡儿坐标表示时，是唯一的。

齐次坐标表示不是唯一的，**通常当 h=1 时，称为规格化齐次坐标**。用齐次坐标技术，可改写平移变换、缩放变换和旋转变换为统一的乘积形式。

规格化齐次坐标下的变换矩阵如下：

1. 平移变换

$$
P' = T(t_x, t_y) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$

2. 旋转变换（坐标原点为旋转中心）

$$
P' = R(\theta) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$

3. 缩放变换

$$
P' = S(S_x, S_y) \cdot P\\

\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix}
=
\begin{bmatrix}
S_x & 0 & 0 \\
0 & S_y & 0 \\
0 & 0 & 1
\end{bmatrix}

\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$



### 复合变换

利用矩阵表示，就可通过计算单个变换的矩阵乘积，将任意顺序变换的矩阵建立为复合变换矩阵。

#### 连续平移

两个连续的平移向量(tx1, ty1)和(tx2, ty2)被用于点 P，那么最后的点坐标可计算为 
$$
P'
= T(tx2, ty2) · { T(tx1, ty1) · P }
= { T(tx2, ty2) · T(tx1, ty1) } · P
$$
计算时，可先计算两个平移变换矩阵的乘积。
$$
T(tx2, ty2) · T(tx1, ty1) = T(tx2 + tx1, ty2+ ty1)
$$
连续平移是可加的。

#### 连续旋转

应用于点 P 的两个连续旋转，得到的点P'的坐标可计算为 
$$
P' = R(θ2) · { R(θ1) · P } = {R(θ2) · R(θ1)} · P
\\
R(θ2) · R(θ1)= R(θ1+θ2)
$$
则P’的坐标可计算为
$$
P' = R(θ1+θ2) · P
$$
连续旋转是可加的。

#### 连续缩放

两个连续缩放操作的变换矩阵连接，产生的复合变换矩阵：
$$
S(sx2, sy2) · S(sx1, sy1) = S(sx1· sx2, sy1· sy1)
$$
连续缩放操作是相乘的，非叠加的。

#### 通用基准点变换

1. **平移使基准点移动到坐标原点。**
2. **针对原点做指定变换。**
3. **反向平移使基准点回到原始位置。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123329996.png" alt="image-20251112123329996" style="zoom:60%;" />

#### 通用方向变换

1. **旋转对象使任意方向与坐标轴方向重合。**
2. **针对坐标轴方向做指定变换。**
3. **反向旋转使任意方向回到原方向。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123501361.png" alt="image-20251112123501361" style="zoom:50%;" />

#### 连接特性

$$
A*B*C = (A*B)*C = A*(B*C)
\\
A*B <> B*A
$$



### 复合二维变换

平移、旋转和放缩矩阵通常记为 T、R 和 S。

二维变换具有结合性：(AB)C=A(BC)。

二维变换不具有交换性，一个例子是如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123813026.png" alt="image-20251112123813026" style="zoom:55%;" />

两个特殊的二维变换：

1. 刚体变换

可以分解为：平移和旋转的组合。

物体的形状没有变化，位置和方位有变化。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123903470.png" alt="image-20251112123903470" style="zoom:67%;" />

2. 仿射变换

可以分解为：平移、旋转和放缩的组合。

保持点的共线性、长度的比例＝>平行线。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123909492.png" alt="image-20251112123909492" style="zoom:67%;" />

### 3D 几何变换

#### 3D 平移

$$
平移向量：t_x, t_y, t_z

\\

T = \begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 3D 缩放

$$
缩放因子：S_x, S_y, S_z

\\

T = \begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

针对给定点缩放（思路依旧是平移，然后按照原点缩放的方式，然后平移回去）：
$$
参数: s_x, s_y, s_z, (x_f, y_f, z_f)

\\

变换矩阵 M = T(x_f, y_f, z_f)S(s_x, s_y, s_z)T(-x_f,-y_f, -z_f)
$$

#### 3D 旋转

1. 绕 Z 轴旋转

绕 Z 轴旋转，Z 坐标不变，矩阵上只有 x, y 有因子。
$$
P' = R_z(\theta) \cdot P\\

R_z(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0\\
\sin\theta & \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

2. 绕 X 轴旋转

同理。
$$
P' = R_x(\theta) \cdot P\\

R_x(\theta) =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & \cos\theta & -\sin\theta & 0\\
0 & \sin\theta & \cos\theta & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

3. 绕 Y 轴旋转

同理。
$$
P' = R_y(\theta) \cdot P\\

R_y(\theta) =
\begin{bmatrix}
\cos\theta & 0 & \sin\theta & 0\\
0 & 1 & 0 & 0\\
-\sin\theta & 0 & \cos\theta & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### 3D 复合变换

一般 3D 物体旋转：

- 旋转轴平行于坐标轴。
- 旋转轴不平行于坐标轴。

1. 旋转轴平行于坐标轴之一。

- **平移使旋转轴与平行坐标轴重合。**
- **完成指定旋转。**
- **反向平移使回到原位置。**

2. 旋转轴不平行于任何坐标轴。

- **平移使旋转轴过原点。**
- **旋转使旋转轴与坐标轴之一重合。**
- **完成指定旋转。**
- **反向旋转。**
- **反向平移。**

下面我们需要细细分析一下这个过程。
$$
旋转轴由两个坐标点确定\\

P1(x1, y1, z1) -> P2(x2, y2, z2)\\

\\

旋转轴矢量\\

V = P2－P1 = (Vx, Vy, Vz)\\

\\

沿旋转轴的单位向量\\

u=V/|V| =(a, b, c)\\

a=(x2-x1)/|V|、b=(y2-y1)/|V|\\

c=(z2-z1)/|V|\\

|V| = sqrt(Vx2 + Vy2 + Vz2)
$$
<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191648140.png" alt="image-20251112191648140" style="zoom:55%;" />

#### 第一步

平移旋转轴矢量使其过原点。
$$
T_1 = \begin{bmatrix}
1 & 0 & 0 & -x_1 \\
0 & 1 & 0 & -y_1 \\
0 & 0 & 1 & -z_1 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$


#### 第二步

旋转物体使旋转轴与 z 轴重合。

这一步又分为两小步：

- 将向量 U 绕 x 轴旋转到 xz 平面上: Rx(α)。
- 将向量 U 绕 y 轴旋转到 z 轴上: Ry(β)。

第一小步，Rx(α)。

**计算 α 的关键点是利用旋转角等于在 Y-Z 平面里的投影来计算。**

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112192902539.png" alt="image-20251112192902539" style="zoom:55%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193020675.png" alt="image-20251112193020675" style="zoom:55%;" />
$$
R_x(\alpha) = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & c/d & -b/d & 0 \\
0 & b/d & c/d & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$
第二小步，Ry(β)。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193438032.png" alt="image-20251112193438032" style="zoom:55%;" />

注意在我们假想的正方向情境下，绕 y 轴旋转是顺时针，是负方向，所以 sin(β)=-a。

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193451270.png" alt="image-20251112193451270" style="zoom:55%;" />
$$
R_y(\beta) = \begin{bmatrix}
d & 0 & -a & 0 \\
0 & 1 & 0 & 0 \\
a & 0 & d & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 第三步

完成指定旋转 Rz(θ)。
$$
R_z(\theta) =
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0\\
\sin\theta & \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 第四步

反向旋转使旋转轴回到原始方向。
$$
R_y(-β)= R_y^{-1}(β)
\\
R_x(-α)= R_x^{-1}(α)
$$

#### 第五步

反向平移使旋转轴回到原始位置。
$$
T_2 = \begin{bmatrix}
1 & 0 & 0 & x_1 \\
0 & 1 & 0 & y_1 \\
0 & 0 & 1 &z_1 \\
0 & 0 & 0 & 1
\end{bmatrix} = T_1^{-1}
$$
整个过程的流程图如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191212935.png" alt="image-20251112191212935" style="zoom:55%;" />

## 观察（取景）变换

观察平面和观察坐标系的确定。

- 观察平面：也叫投影平面。
- 观察坐标系：用来指定观察者的观察位置及投影平面的参照系。

观察坐标系的建立：

- 观察参考点 Pref，观察坐标原点 P0。
- 观察平面法向量 N。观察 Zv 轴的正方向和观察平面方向。Zview = N = P0 - Pref
- 建立 Yview 轴的正方向，将 V 在观察平面上投影，即可得到 Yview 轴。
- 指定观察向上向量，只要与 N 不平行，如：Vup = (0,1,0)。
- 利用右手原则得到 Xview, Yview。X_view = V_up×Z_view，Y_view = Z_view×X_view。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113165742798.png" alt="image-20251113165742798" style="zoom:50%;" />

视点坐标系：

- 视点坐标系定义于世界坐标系中。
- 类似拍照片：
  - 照相机镜头的朝向：视线方向。
  - 照相机的位置。
  - UP 方向。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170551868.png" alt="image-20251113170551868" style="zoom:60%;" />

视点坐标系的交互建立：

- 坐标原点 C = (Cx, Cy, Cz)：相机的位置。

- 单位向量 N = (Nx, Ny, Nz)：镜头的朝向。
- 与 N 不平行的向量 UP：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170801982.png" alt="image-20251113170801982" style="zoom:65%;" />

- 得到两个向量 U = (Ux, Uy, Uz) 和 V = (Vx, Vy, Vz)，然后单位化。
- 四个矢量 C、U、V、N 组成了视点坐标系。
- 由世界坐标系到视点坐标系的取景变换，其中 (x, y, z, 1) 为世界坐标系中的点，(u, v, n, 1) 为视点坐标系中的点。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170841181.png" alt="image-20251113170841181" style="zoom:75%;" />

## 投影变换

### 投影分类

- **平行投影：物体坐标位置沿平行线变换到观察平面上。**
- **透视投影：物体坐标位置沿收敛于某点的直线变换到观察平面。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171111232.png" alt="image-20251113171111232" style="zoom:60%;" />

二者的对比：

- **平行投影保持对象相关比例，立体感不强，常用于建筑和工程制图。**
- **透视投影符合人类的视觉特点，不保持对象的相关比例，但立体感较好。**

投影的分类图：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171442051.png" alt="image-20251113171442051" style="zoom:55%;" />

### 平行投影

正投影的投影向量垂直于观察平面，斜投影不垂直。

正投影：

- **正三面投影**：三视图（正视图、俯视图、侧视图），投影平面法向量与三个坐标轴之一**平行**。
- **轴测正投影**：**显示物体多个侧面**的正投影。
- **等轴测投影：投影平面与每个坐标轴的交点距原点距离相等。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171910449.png" alt="image-20251113171910449" style="zoom:50%;" />

斜投影：

- **斜等测投影**：α 等于 45°，生成的视图。**所有垂直于投影平面的线条投影后长度不变。**
- **斜二测投影**：投影角满足 tanα=2(63.4°) 生成的视图。**垂直于投影平面的线条投影后得到一半长度。**

### 透视投影

透视投影是一种中心投影法。

透视投影类型：

- **灭点：3D 物体的一组平行线投影后收敛于一点，此点称为灭点。** 
- **主灭点：3D 物体平行于坐标轴的平行线收敛产生的灭点 -> 主灭点。**
- **一点、二点、三点透视。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113172455456.png" alt="image-20251113172455456" style="zoom:55%;" />

投影中心与投影平面之间的距离为有限的，例如室内白炽灯的投影，视觉系统等。特点是产生**近大远小的视觉效果**，由它产生的图形深度感强，看起来更加真实。 

透视投影点坐标计算：

1. 假定投影参考点在 z 轴 的（xprp, yprp, zprp)，投影平面在 zvp，直线参数方程为：

$$
x_r = x - (x - x_{prp})u\\
y_r = y - (y - y_{prp})u\\
z_r = z - (z - z_{prp})u\\

u 的取值范围为 [0,1], (x_r, y_r, z_r) 代表投影线上任意点。
$$

2. 投影点的 Z 坐标是 Zvp，计算 u：

$$
u = (z_{vp} - z) / (z_{prp} - z)
$$

3. 计算投影点的 X、Y 坐标，带入 u 即可。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113172932538.png" alt="image-20251113172932538" style="zoom: 67%;" />

#### 透视投影变换矩阵

透视投影变换矩阵，当其中的元素（p , q , r)取非全 ０ 时，能产生透视效果。

![image-20251113173510466](https://cdn.davidingplus.cn/images/2025/11/13/image-20251113173510466.png)

1. 一点透视

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113173737378.png" alt="image-20251113173737378" style="zoom:55%;" />

现在来对 Ｙ 的取值情况进行讨论：

- 当 y = 0（在 X0Z 坐标平面内）：[x’ y’ z’ 1] = [x 0 z 1]。
- 当 y 趋于无穷：[x’ y’ z’ 1] = [0  1/q  0  1]。

当 Ｙ 值无限变大时，所有点经过变换后均集中于 Ｙ 轴上的 1/q 处，于是所有平行于 Ｙ 轴的直线将延伸相交于此点。该点(0，1/q，0)称为灭点。形成一个灭点的透视称为一点透视。为了取得较好的效果，取 q<0。（让灭点位于Ｙ轴的负半轴上）

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174102380.png" alt="image-20251113174102380" style="zoom:65%;" />

2. 两点透视

如果在 p , q , r 中有两个非 ０ 元素，这时将会产生两个灭点，得到的透视图称为两点透视，或称**成角透视**。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174322785.png" alt="image-20251113174322785" style="zoom:55%;" />

3. 三点透视

以此类推，当 p、q、r 三个元素全为非 0 时，变换的结果将形成三点透视。产生的三个灭点将分别位于 Ｘ 轴上的 1/p 处、Ｙ 轴上的 1/q 处和 Ｚ 轴上的 1/r 处。此时，投影平面与三坐标轴均不平行。这时的三组平行线均产生灭点。

最后，可以简单的推断：

- 与一个坐标轴垂直的平面作为投影平面的话，该平面上的投影一定是一点投影。
- 与两个坐标轴相交且与第三个坐标轴不相交的平面作为投影平面的话，该平面上的投影一定是两点投影。
- 与三个坐标轴都相交且不含有任何坐标轴的平面作为投影平面的话，该平面上的投影一定是三点投影。

#### 透视图的生成

1. 一点透视图

在生成一点透视图时，为了避免特殊位置透视，使产生的透视图立体感较好，通常要在进行透视变换前先将立体平移到一个合适的位置（例如离开坐标系中心)，然后再进行透视变换。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174912026.png" alt="image-20251113174912026" style="zoom:67%;" />

2. 两点透视图

先使立体绕 Ｚ 轴旋转一个角度 θ，以使得立体上原平行于坐标平面 XOZ 和 YOZ 的表面与投影面 XOZ 产生一定的倾斜角（成角透视），向 XOZ 投影面作透视投影。

变换矩阵：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174959778.png" alt="image-20251113174959778" style="zoom:55%;" />

在以上生成的变换矩阵中，有两个透视参数为非 ０（qsinθ, qcosθ)，故生成的透视图为两点透视。**在两点透视图中，只有原来与 Ｚ 轴平行的立体上的棱线仍旧保持与 Ｚ 轴平行，其余的棱线（例如原来与 Ｘ 轴及 Ｙ 轴平行的棱线）将倾斜（成角）。**

3. 三点透视图

类似的。先使立体绕 Ｚ 轴旋转一个角度 θ，再绕 Ｘ 轴旋转一个角度 Φ（类似于轴测变换），这样使得立体上原平行于三个坐标平面的表面均与投影面 XOZ 产生一定的倾斜角；向 XOZ 投影面作透视投影。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113175432804.png" alt="image-20251113175432804" style="zoom:67%;" />

## 设备变换

在投影平面上，有一个矩形区域称为视窗。

- “视域四棱锥” 图中的矩形。
- 物体投影后：二维齐次坐标表示。

**设备变换：投影后二维齐次坐标除以最后一个坐标分量 w，便得到了规格化设备坐标。**

## 视窗变换

屏幕坐标系：通常以像素为单位。

视窗变换

- 二维变换：将定义在视窗中的规格化设备坐标转换到以像素为单位的屏幕坐标。
- 扫描转换：将连续的几何物体转换为离散的光栅表示。

## 三维变换流程图（牢记）

<img src="https://cdn.davidingplus.cn/images/2025/11/12/image-20251112195236840.png" alt="image-20251112195236840" style="zoom:50%;" />

这几个变换不同的作用总结：

1. 模型变换（Model Transformation）
   - 作用：**将物体从模型坐标系（物体自身的局部坐标）变换到世界坐标系**。意义：确定物体在整个三维场景中的位置、朝向和大小。
   - 常见操作：平移、旋转、缩放。
   - 举例：把一个立方体从原点移动到 (3, 0, 2)，并绕 y 轴旋转 45°。
2. 取景变换（View Transformation）
   - 作用：**将场景从世界坐标系变换到观察（摄像机）坐标系。**
   - 意义：相当于“确定摄像机的视角”，即从哪个位置、方向去看这个世界。
   - 实质：通过移动与旋转整个世界，让摄像机位于原点并面向 -Z 方向。
   - 参数：通常由摄像机位置、目标点、上方向确定。
3. 投影变换（Projection Transformation）
   - 作用：**把三维场景投影到二维平面（视平面）。**
   - 分类：
     - 透视投影：近大远小，符合人眼视觉。
     - 平行投影：无透视变化，保持比例，用于工程绘图。
   - 结果：将三维点转为“规范立方体空间”（裁剪空间），为后续设备映射做准备。
4. 设备变换（Device Transformation）
   - 作用：**将投影后的坐标标准化为设备坐标**（NDC，Normalized Device Coordinates）。
   - 意义：将投影结果进行透视除法（除以齐次坐标 w）得到规格化设备坐标，便于硬件统一处理。
5. 视窗变换（Viewport Transformation）
   - 作用：**将设备坐标映射到屏幕坐标（像素坐标）。**
   - 意义：确定最终图像显示在屏幕上的具体位置与大小。
   - 最终输出：屏幕上可见的二维图像。

# 第六章 裁剪

## 本章复习重点

- 二维剪裁和三维剪裁在渲染 pipeline 中的位置。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190221289.png" alt="image-20251113190221289" style="zoom:60%;" />

- Cohen-Sutherland 裁剪算法。
- 中点分割算法。
- 梁友栋剪裁方法。

## 关于裁剪

裁剪

- 二维线裁剪。
- 二维多边形裁剪。
- 文本裁剪。
- 三维裁剪。

裁剪是确定场景或画面中位于给定区域(2D 或 3D 裁剪窗口)之内的部分。

裁剪还可用于图形反走样、隐藏线、隐藏面、阴影、纹理等算法中。

裁剪推广应用：

- 多面体对多面体的裁剪，实体造型系统中执行布尔运算。
- 在窗口系统中复制、移动或删除画面中某一部分(Cut-Copy-Paste)。

## 二维线裁剪

图形裁剪的策略：

- 先变换后裁剪：将图形经过扫描转换后变成像素的集合，然后对图形中的每一个像素进行裁剪。
- 先裁剪后变换：**将原始图形进行裁剪，保留窗口内的可见部分，舍弃窗口外的不可见部分。然后对窗口内保留的这部分图形进行扫描转换。**
- 先裁剪后变换！可以省去许多不必要的扫描转换的工作。

### 点的裁剪

对于一点 P(x,y)，要判断其是否可见：
$$
x_{min} \le x \le x_{max}\ and\ y_{min} \le y \le y_{max}
$$
满足上述不等式组的点则在窗口范围内，则保留；反之，该点落在窗口外，应裁剪。

### 直线的裁剪

对于矩形窗口，任何直线至多只有一段处于该窗口之内，即在此窗口范围内永远不会产生一条直线的两条或更多的可见部分线段。

基本思想是判断直线与窗口的位置关系，确定该直线是完全可见、部分可见或完全不可见，输出处于窗口内线段的端点，并显示此线段。

#### Cohen-Sutherland 裁剪算法

对矩形窗口的不同区域进行编码：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184303324.png" alt="image-20251113184303324" style="zoom:67%;" />

编码规则：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184321649.png" alt="image-20251113184321649" style="zoom:55%;" />

算法运行过程：

1. 若某线段两个端点的四位二进制编码全为 0000，线段位于窗口内，显示之。
2. 若对两端点的四位二进制编码进行逻辑与运算（&）结果不为 0，线段位于窗口外，直接舍弃。
3. 若线段既不能直接保留，也不能直接舍弃，它可能与窗口相交。这个时候对线段进行再分割，并找到与窗口边线的一个交点，根据交点位置，赋予 4 位二进制编码。对分割后的线段，舍弃一定在窗口外部分，另一部分做进一步检查。

求交的过程：

1. 将两个端点的编码 CtCbCrCl 进行逻辑或操作。
2. 根据其结果中 1 的位置来确定可能相交的窗口边。
3. 求交按照固定的顺序来进行（左右下上或上下右左）。
4. 一条线段与窗口最多求交 4 次。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184821113.png" alt="image-20251113184821113" style="zoom:55%;" />

特点：简单，易实现。依次裁剪在窗口外部分，直到直线完全处于窗口内。快速判断线段的完全可见和显然不可见，巧妙的编码方法。

#### 中点分割算法

与 Cohen-Sutherland 裁剪算法类似，但是求交的过程不同。

中点将线段分割为两个部分，必然有一个部分存在最近可见点（交点）。**保留存在最近可见点部分，舍弃另一部分。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113185219153.png" alt="image-20251113185219153" style="zoom:55%;" />

求出中点以后，如何判断应该舍弃线段的哪个部分呢？

1. 若如果 P1 与 P 同侧，移动 P1 点；（即可能的交点只能出现在 PP2 段，此时的新线段是 PP2，相当于 P1 移动打了 P）。

```cpp
if ( (C1 & C) != 0 ) P1 = P;
```

2. 若 P1 与 P 不同侧，移动 P2 点。（即可能的交点只能出现在 P1P 段）。

```cpp
if ( (C2 & C) != 0 ) P2 = P;
```

3. 然后，将中点分割进行到底！最终收敛到最近可见点！

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113185433780.png" alt="image-20251113185433780" style="zoom:67%;" />

特点：

- 求交点的次数（n）与线段长度（L)有关，其关系为：L=2^n 。线段长度为 256，则求交点的次数为 8。
- **求出的交点是边界上的有效交点（最近可见点），而非边界及其延长线上的交点。**这点与 Cohen-Sutherland 算法不同。
- 使用加法和除法，硬件容易实现。

#### 梁友栋-Barsky 裁剪算法

TODO。

## 二维多边形裁剪

多边形的各条边是顺次连接。

直线裁剪：

- 把一条线段的两个端点孤立考虑，会产生孤立线段。
- 裁剪之后各条边不一定能保持原来的连接顺序。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190557762.png" alt="image-20251113190557762" style="zoom:55%;" />

多边形可以描述为一组顶点按一定顺序连接而成的有向点列。一般可将多边形的顶点按逆时针方向顺序形成有向线段，进而连接成一个环来描述多边形的组成。数据结构上，可用链表结构来描述。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190736546.png" alt="image-20251113190736546" style="zoom:60%;" />

### Sutherland-Hodgman 算法

每次用窗口的一条边界对多边形进行裁剪。把落在窗口外部的图形去掉，落在窗口内部的图形保留。并把它作为下一次待裁剪的多边形。连续用窗口的四条边界对原始多边形进行裁剪后，最后得到的就是裁剪后的结果多边形。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190828219.png" alt="image-20251113190828219" style="zoom:55%;" />

对**凸多边形**应用本算法可以得到正确的结果，但是**对凹多边形的裁剪将显示出一条多余的直线**。这种情况在裁剪后的多边形有两个或者多个分离部分的时候出现。因为只有一个输出顶点表，所以表中最后一个顶点总是连着第一个顶点。

解决这个问题有多种方法，一是把凹多边形分割成若干个凸多边形，然后分别处理各个凸多边形。二是修改本算法，沿着任何一个裁剪窗口边检查顶点表，正确的连接顶点对。三就是 Weiler-Athenton 算法。

### Weiler-Athenton 算法

我们按照一个方向，将多边形和裁剪窗口的交点分成两类。一类是入点，即**裁剪多边形由该点进入裁剪窗口**（顺时针），如图中 a、c、e。另一类是出点，如图 b、d、f。

算法从被裁剪多边形的一个入点开始，**碰到入点，沿着被裁剪多边形按顺时针方向搜集顶点序列；而当遇到出点时，则沿着裁剪窗口按顺时针方向搜集顶点序列**。

按上述规则，**如此交替地沿着两个多边形的边线行进，直到回到起始点**。这时，收集到的全部顶点序列就是裁剪所得的一个多边形。

由于可能存在分裂的多边形，因此算法要考虑：**将搜集过的入点的入点记号删去，以免重复跟踪**。将所有的入点搜集完毕后算法结束。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191034786.png" alt="image-20251113191034786" style="zoom:55%;" />

执行过程如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191950706.png" alt="image-20251113191950706" style="zoom:55%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191957562.png" alt="image-20251113191957562" style="zoom:55%;" />

特点：

1. 裁剪窗口可以是矩形、任意凸多边形、任意凹多边形。
2. 可实现被裁剪多边形相对裁剪窗口的内裁或外裁，即保留窗口内的图形或保留窗口外的图形，因此在三维消隐中可以用来处理物体表面间的相互遮挡关系。
3. 裁剪思想新颖，方法简洁，裁剪一次完成，与裁剪窗口的边数无关。

## 字符裁剪

串精度裁剪，字符精度裁剪，以及笔画象素精度：将笔划分解成直线段对窗口作裁剪，构成字符最小元素裁剪。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113192136443.png" alt="image-20251113192136443" style="zoom:67%;" />

## 三维裁剪

裁剪对象：线裁剪、面裁剪。

裁剪窗口：规范的立方体、视域四棱锥。

## 关于三维变换与裁剪

什么时候裁剪？

1. 投影之前裁剪：三维裁剪。

优点：只对可见的物体进行投影，**提高消隐效率**。缺点：三维裁剪相对复杂。

2. 投影之后裁剪：二维裁剪。

优点：二维裁剪相对容易。缺点：**需要对所有的物体进行投影变换。**

# 第七章 光栅化

光栅化在三维变换流程图中的位置如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113192724362.png" alt="image-20251113192724362" style="zoom:60%;" />

## 本章复习重点

- 区域填充算法及其递归函数实现。
- 扫描线算法中如何判断一个点是在面内还是面外。
- 分类的边表 ET 构建方法。
- 活化边链表 AEL 构建方法。
- 参考第 7 章案例。

## 光栅图形的基本概念

光栅图形：

- 本质：点阵表示。
- 特点：面着色，画面明暗自然、色彩丰富。
- 与线框图相比：更加生动、直观、真实感强。

图形学中多边形的两种表示方式：

1. 顶点表示：用多边形的有序顶点序列表示多边形。

优点：直观、几何意义明显、存储量小。缺点：难以判断哪些像素位于多边形内部、不能直接用多边形着色。

2. 点阵表示：用位于多边形内部的像素集合来表示多边形。

优点：便于用帧着色器（Frame Buffer）表示图形。面着色所需的图形表示。缺点：丢失几何信息、存储量大。

多边形的扫描转换：把顶点表示转换为点阵表示。**从多边形的给定边界出发，求出其内部的各个像素。并给帧缓冲器中各个对应元素设置相应灰度或颜色。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193344875.png" alt="image-20251113193344875" style="zoom:67%;" />

## 区域填充

区域的表示：

1. 内部表示：把给定区域内部的像素枚举出来。
2. 外部表示：把区域边界上的像素枚举出来。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193633027.png" alt="image-20251113193633027" style="zoom:55%;" />

区域填充的类型：

1. 四连通区域：区域内任意两个像素，从一个像素出发，可以通过上、下、左、右四种运动，到达另一个像素。
2. 八连通区域：区域内任意两个像素，从一个像素出发，可以通过水平、垂直、正对角线、反对角线八种运动，到达另一个像素。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193704090.png" alt="image-20251113193704090" style="zoom:55%;" />

### 区域种子填充算法

假设内部表示区域为 G，其中的像素原有颜色为 G0，需要填充的颜色为 G1。算法需要提供一个种子点(x, y)，它的颜色为 G0。以四连通区域为例。

注意整个填充是一个**递归**的过程。考试写填充顺序的时候需要注意。

1. 内部表示区域种子填充算法

```cpp
Flood_Fill_4(x, y, G0, G1)
{
    if (GetPixel(x, y) == G0) // GetPixel(x,y) 返回(x,y)的颜色
    {
        SetPixel(x, y, G1); // 将(x,y)的添上颜色G1
        Flood_Fill_4(x - 1, y, G0, G1);
        Flood_Fill_4(x, y + 1, G0, G1);
        Flood_Fill_4(x + 1, y, G0, G1);
        Flood_Fill_4(x, y - 1, G0, G1);
    }
}
```

2. 边界表示区域种子填充算法

```cpp
Fill_Boundary_4_Connnected(x, y, BoundaryColor, InteriorColor)
// (x,y) 种子像素的坐标；
// BoundaryColor 边界像素颜色； InteriorColor 需要填充的内部像素颜色
{
    if (GetPixel(x, y) != BoundaryColor && GetPixel(x, y) != InteriorColor)
    // GetPixel(x,y): 返回像素(x,y)颜色
    {
        SetPixel(x, y, InteriorColor); // 将像素(x, y)置成填充颜色
        Fill_Boundary_4Connnected(x, y + 1, BoundaryColor, InteriorColor);
        Fill_Boundary_4Connnected(x, y - 1, BoundaryColor, InteriorColor);
        Fill_Boundary_4Connnected(x - 1, y, BoundaryColor, InteriorColor);
        Fill_Boundary_4Connnected(x + 1, y, BoundaryColor, InteriorColor);
    }
}
```

## 多边形的扫描转换

### 逐点判断算法

逐个像素判别其是否位于多边形内部。

判断一个点是否位于多边形内部：**射线法**。从当前像素发射一条不经过顶点的射线，计算射线与多边形的交点个数。**内部：奇数个交点，外部：偶数个交点**。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194409882.png" alt="image-20251113194409882" style="zoom:55%;" />

问题在于速度慢，并且没有考虑像素之间的联系。最终结论是不可取。

### 连贯性

扫描线算法充分利用了相邻像素之间的连贯性，避免了对像素的逐点判断和求交运算，提高了算法效率。

各种连贯性：区域连贯性、扫描线连贯性、边的连贯性。

#### 区域连贯性

区域的连贯性是指多边形定义的**区域内部相邻的像素具有相同的性质**。例如具有相同的颜色。

两条扫描线之间的长方形区域被所处理的多边形分割成若干梯形(三角形可以看作退化梯形)。梯形的底边为扫描线，梯形的腰为多边形的边或窗口边缘。

梯形分为两类：多边形内部（图中红色）和多边形外部（图中绿色）。两类梯形在多边形内部相间排列(相邻的两个梯形必然有一个位于多边形内部，有一个在多边形外部)。

如果上述梯形属于多边形内(外)，那么该梯形内所有点的均属于多边形内(外)。这样就把逐点判断转换成了区域判断。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194626999.png" alt="image-20251113194626999" style="zoom:55%;" />

#### 扫描线连贯性

交点序列：扫描线与多边形的交点个数为**偶数**(1, 2, 3, 4, 5, 6)（一进一出）。

红色区间(1, 2)、(3, 4)、(5, 6)位于多边形内部。其余绿色区间位于多边形外部。两类区间相间排列。

如果上述交点区间属于多边形内(外)，那么该区间内所有点均属于多边形内(外)。这样就把逐点判断转换成了区间判断。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194859565.png" alt="image-20251113194859565" style="zoom:70%;" />

#### 边的连贯性

相邻两条扫描线的 y 相差 1。相邻扫描线与多边形的同一条边的交点的关系如下：

当知道扫描线与一条边的一个交点之后，通过上述公式可以通过增量算法迅速求出其他交点。
$$
\frac{y_1 - y_{11}}{x_1 - x_{11}} = k

\\

x_1 = x_{11} + \frac{1}{k}
$$
<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195054747.png" alt="image-20251113195054747" style="zoom:60%;" />

**边的连贯性是连接区域连贯性和扫描线连贯性的纽带。**

扫描线连贯性＋边连贯性＝区域连贯性

#### 奇异点

奇异点是**扫描线与多边形交交于多边形的顶点**。

奇异点计为几个交点？

- 扫描线 1：一个交点。
- 扫描线 2：两个交点。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195642366.png" alt="image-20251113195642366" style="zoom:67%;" />

极值点：相邻三个顶点的 y 坐标满足如下条件，即**相邻三个顶点位于扫描线的同一侧**。
$$
(y{i-1} - y_i)(y_{i+1} - y_i) \ge 0
$$
非极值点则反过来，相邻三个顶点位于扫描线的两侧。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195845379.png" alt="image-20251113195845379" style="zoom:65%;" />

关于奇异点的处理，**在极值点处，按两个交点计算，在非极值点处，按一个交点计算**。

实际计算前，奇异点(非极值点)的预处理。将扫描线上方线段**截断一个单位**，这样扫描线就只与多边形有一个交点。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113200107564.png" alt="image-20251113200107564" style="zoom:50%;" />

### 多边形扫描转换算法

核心思想(从下到上扫描)：

1. 计算扫描线 y = ymin 与多边形的**交点**，通常这些交点由多边形的顶点组成。
2. 根据多边形**边的连贯性**，按从下到上的顺序求得各条扫描线的交点序列。
3. 根据**区域和扫描线的连贯性**判断位于多边形内部的区段。
4. 对位于多边形内的直线段进行**着色**。

算法实现的数据结构：

1. **分类的边表 ET (Sorted Edge Table)：记录多边形信息。**
2. **活化边链表 AEL (Active Edge List)：记录当前扫描线信息。**

边的数据结构：

1. ymax：边的上端点的 y 坐标。
2. x：边的下端点 x 坐标，在活化边链表中，表示扫描线与边的交点的 x 坐标。
3. dx：边的斜率的倒数。
4. next：指向下一条边的指针。

分类的边表 ET：按边的下端点的纵坐标*y*对非水平边进行分类的指针数组。

1. 下端点的纵坐标 y 值等于 i 的边，归入第 i 类；
2. 同一类中，各边按 x 值(x 值相等时，按 dx 的值)递增的顺序排成行；
3. 水平边不加入分类边表中。

**注意 P0 和 P4 是非极值点，所以按一个交点计算，在扫描转换的时候需要截掉底部一个像素的宽度，所以起始的坐标需要 y + 1。**

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202037218.png" alt="image-20251113202037218" style="zoom:55%;" />

活化边链表 AEL：由与当前扫描线相交的边组成。

1. 记录了多边形的边沿扫描线的交点序列。
2. 根据边的连贯性不断刷新交点序列。
3. 基本单元是边(与扫描线相交的边)。
4. 与分类边表不同：分类边表记录初始状态。活化边表随扫描线的移动而动态更新。

注意 Xcur 填入的是扫描线和当前直线的交点的 x 坐标。

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202210093.png" alt="image-20251113202210093" style="zoom:55%;" />



算法执行过程（我们只需要掌握写 ET 和 AEL 即可）

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202847977.png" alt="image-20251113202847977" style="zoom:60%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202854415.png" alt="image-20251113202854415" style="zoom:60%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202859369.png" alt="image-20251113202859369" style="zoom:60%;" />

<img src="https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202903871.png" alt="image-20251113202903871" style="zoom:60%;" />

优点：充分利用多边形的区域、扫描线和边的连贯性，避免了反复求交的大量运算。

不足：算法的数据结构和程序结构复杂。对各种表的维持和排序开销太大，适合软件实现而不适合硬件实现。

## 多边形的扫描转换与区域填充的比较

基本思想不同：

1. 多边形扫描转换将多边形顶点表示转换为点阵表示，扫描过程利用了多边形的各种连贯性。
2. 区域填充只改变区域的颜色，不改变区域的表示方法。填充过程利用了区域的连贯性。

对边界的要求不同：

1. 多边形扫描转换只要求每一条扫描线与多边形有偶数个交点。
2. 区域填充中，四连通区域必须是封闭的八连通边界。八连通区域必须是封闭的四连通边界。

出发点不同：

1. 区域填充：知道需要区域内一个种子点(复杂计算)。
2. 多边形扫描转换：没有要求。

# 第十二章 OpenGL 编程基础

## 10 中基本图元模型

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192540046.png" alt="image-20251111192540046" style="zoom:55%;" />

## 程序的基本结构

一段实例代码如下：

```cpp
#include <windows.h>
#include <gl/gl.h>
#include <gl/glu.h>
#include <gl/glaux.h>
#include <stdio.h>


void myinit(void);
void CALLBACK myReshape(int w, int h);
void CALLBACK display(void);


void myinit(void)
{                                     // 初始化
    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色
}
void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor4f(0.2, 0.8, 1.0, 1.0); // 选颜色(R,G,B)
    glRotatef(30, 1.0, 1.0, 0.0);  // 做旋转变换
    auxWireCube(1.0);              // 绘制六面体的虚线图
    glFlush();                     // 强制绘图，不驻留缓存
     
}

void CALLBACK myReshape(int w, int h)
// 用于窗口大小改变时的处理，与绘图无关
{
    glViewport(0, 0, w, h);
}


void main(void)
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA); // 窗口显示单缓存和彩色模式
    auxInitPosition(0, 0, 200, 200);           // 屏幕左上点及大小
    auxInitWindow("openglsample.c");           // 初始化窗口，标题
    myinit();
    auxReshapeFunc(myReshape);
    auxMainLoop(display);
}
```

绘制效果如图：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192641692.png" alt="image-20251111192641692" style="zoom:55%;" />

代码中需要注意以下几点：

1. 头文件使用

若应用程序使用 OpenGL 核心函数，应包括头文件 <gl/gl.h>。

使用 GLU 库函数，应包括头文件 <gl/glu.h>。

使用 AUX 库函数，应包括头文件 <gl/glaux.h>。

使用 WGL 和 Win32 应包括头文件 <windows.h>。

2. 程序的基本结构

（1）定义窗口

Windows 下的 OpenGL 实现提供了一个辅助函数库 aux，用于解决开窗口和处理输入事件等问题

窗口管理函数：

```cpp
void auxInitDisplayMode(Glbitfield mask); // 函数定义窗口的特性，如颜色和缓存区的性质。

// 窗口显示单缓存和 RGB(彩色)模式。
// auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);

void auxInitPosition(Glint x, Glint y, Glint width, Glint height); // 定义窗口在屏幕上的位置和大小。

void auxInitWindow(Glbyte *titleString) // 打开窗口。窗口的标题为字符串 titleString。窗口把 ESC 键与退出函数联系起来，可以用来关闭窗口，退出程序。
```

处理输入事件:

当改变窗口尺寸、移动窗口、重新显示窗口时，由 auxReshapeFunc(myReshape) 调用函数 myReshape 重新定义窗口属性。通常 myReshape 函数调用 glViewPort 函数，对当前图形进行裁剪，重新定义投影矩阵等。

OpenGL 辅助函数库中还包括处理键盘和鼠标输入事件的函数。

（2）初始化操作

由于 OpenGL 的绘图方式是由一系列的状态确定的，因而在绘制图形前需要做一些准备工作，包括清缓存区、定义光照模型、纹理映射等基本操作的初始化状态、设置三维视景体、定义视口。 

例如：

```cpp
glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色。

glClear(GL_COLOR_BUFFER_BIT); // 将颜色缓存清为 glClearColor 命令所设置的颜色，即背景色。
```

（3）设置观察坐标系下的取景模式和取景框位置及大小，主要利用了三个函数：

```cpp
// 设置屏幕上视口大小。(x, y)指定视口左下角在窗口坐标系中的位置，width 和 height 分别确定矩形视口宽和高，均以像素为单位。注意：视口的大小和尺寸是在窗口坐标系中进行度量的，默认状态下其坐标原点位于窗口的左下角，其尺寸与窗口的大小相同。
void glViewport(GLint x, Glint y, Glsizei width, Glsizei height);

// 设置投影方式为正交投影（平行投影），其取景体积是一个各面均为矩形的六面体，在默认状态为平行正交投影。
void glOrtho(left, right, bottom, top, near, far);

// 设置投影方式为透视投影，其取景体积是一个截头锥体。
// 它通过指定 x-z 平面内的视角大小及宽高比来确定沿视线方向的棱锥，并通过指定远、近剪切面与视点间的距离来截断棱锥，得到观察体。
void gluPerspective(fovy, aspect, zNear, zFar);
```

（4）使用 OpenGL 的库函数构造几何物体对象的数学描述，包括点线面的位置和拓扑关系、几何变换、光照处理等，这是 OpenGL 程序的主要部分。

（5）程序的微机运行环境配置

程序中除了包含必需的头文件如 <windows.h> <gl/gl.h> <gl/glaux.h> <gl/glu.h> 外。在创建执行文件时，在 VC 环境设置中要链接 opengl32.lib, glu32.lib 和 glaux.lib 三个函数库。运行已创建的执行文件时，在 windows\system 目录下要有 opengl32.dll，glu32.dll 两个动态连接库。

## 基本绘制单元

要绘制某个几何对象，必须指明究竟是哪种类型的几何对象（例如点、线和多边形）。

OpenGL 绘制部分的代码结构类似于代码分段的形式：

```cpp
glBegin(mode);

	...

    glVertex3f(x,y,z);
    glVertex3f(x,y,z);
    glVertex3f(x,y,z);

	...

glEnd();
```

### 点的绘制

OpenGL 中点定义为一个方块，在默认状态下，点是屏幕上的一个像素。在 OpenGL 中，一个点是当作一个 n（2,3,4）维向量来处理的。

例如在屏幕上绘制三个点：

```cpp
glBegin(GL_POINTS)
    glVertex3f(1.0, 0.0, 0.0);
    glVertex3f(1.0, 1.0, 0.0);
    glVertex3f(0.0, 1.0, 1.0);
glEnd();
```

### 线的绘制

与数学意义上两端无限延伸的直线不同，OpenGL的线是数学定义中的线段，用**成对的端点**来描述。

```cpp
// 一条由坐标原点到点（1.0,1.0）的线段。
glBegin(GL_LINES)
    glVertex2f(0.0, 0.0);
    glVertex2f(1.0, 1.0);
glEnd()；
```

### 多边形的绘制

多边形指封闭线段围成的区域。但 OpenGL 中可以描述的多边形有两点限制：多边形的边除了多边形的顶点外不允许相交，即确保多边形为**简单多边形**；多边形为**凸多边形**，即任给多边形的两个内部点，其连线完全在多边形内。

```cpp
// 其中，* 表示 glVertex 函数的上述任一种组合形式，由多边形顶点 v0,v1,…,vn 的表示形式而定。注意：多边形顶点应按一定顺序排列（如逆时针）。
glBegin(GL_POLYGON);
    glVertex*(v0);
    glVertex*(v1);
    ...
    glVertex*(vn);
glEnd();
```

### 矩形的绘制

用的比较频繁，OpenGL 专门设置了绘制矩形的函数。

```cpp
// 矩阵的左上、右下角点坐标分别为（x1,y1）和(x2,y2)，或者用数组指针 v1、v2 表示。用上述函数描述的矩形位于 z=0 平面内，并且各边分别平行于 x、y 轴。但注意：经过坐标变换之后，这些特性可能改变。 
void glRect{dfis}(TYPE x1, TYPE y1, TYPE x2, TYPE y2);
void glRect{dfis} v(TYPE *v1, TYPE *v2);
```

## 例 10.2

```cpp
void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor4f(1.0, 1.0, 1.0, 1.0); // 选颜色(R,G,B)
    glPointSize(6.0);                // 设置点的大小

glBegin(GL_POINTS);              // 在屏幕上绘制三个点
    glVertex3f(0.1, 0.2, 0.0);
    glVertex3f(0.2, 0.7, 0.0);
    glVertex3f(0.5, 0.8, 0.0);
glEnd();

glBegin(GL_LINES); // 在屏幕上绘制一条线段
    glVertex2f(0.0, 0.4);
    glVertex2f(-0.3, 0.8);
glEnd();

glBegin(GL_POLYGON); // 在屏幕上绘制一个四边形
    glVertex2f(-0.6, 0.0);
    glVertex2f(-0.4, 0.0);
    glVertex2f(-0.4, 0.3);
    glVertex2f(-0.6, 0.4);
glEnd();

    glColor3f(1.0, 0.0, 0.0);    // 设置当前颜色为红色
    glColor3f(0.0, 0.0, 1.0);    // 设置当前颜色为蓝色
    glRectf(0.5, 0.5, 0.7, 0.7); // 绘制一个矩形
    glColor3f(0.0, 1.0, 0.0);    // 设置当前颜色为绿色
    glRectf(0.8, 0.8, 0.9, 0.9); // 绘制一个矩形
    glRectf(0.2, 0.2, 0.4, 0.4); // 绘制一个矩形
   	glFlush();                  // 强制绘图，不驻留缓存
}
```

最终绘制效果如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200407898.png" alt="image-20251111200407898" style="zoom:70%;" />

## 坐标变换

在二维平面上创建三维物体的过程：在三维空间中创建所绘制物体的模型，由计算机经过适当的变换，将三维坐标系中的点转换为屏幕上的相应位置，以得到理想的视觉效果。

OpenGL 就是实现将物体的各个顶点通过各种变换矩阵的作用映射到屏幕的过程。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200529792.png" alt="image-20251111200529792" style="zoom:50%;" />

（1）通用的矩阵操作命令

```cpp
// 参数取值：GL_MODELVIEW、GL_PROJECTION或GL_TEXTURE
// 默认的选定矩阵为 GL_MODELVIEW 变换矩阵。
void glMatrixMode(Glenum mode);

// OpenGL 中的变换命令都是对当前矩阵进行操作，因此在选定可修改矩阵后，应首先用上述命令设置当前操作矩阵为单位矩阵。
void glLoadIdentity(void);
```

（2）模型观察变换

模型观察变换过程就是一个将顶点坐标从世界坐标变换到视觉坐标的过程。

世界坐标系是一个右手坐标系，是固定不变的，在初始态下，其 x 轴为沿屏幕水平向右，y 轴为沿屏幕垂直向上，z 轴则为垂直屏幕面向外指向用户

观察坐标系是一个左手坐标系，是可以活动的。在初始态下，原点及 x、y 轴分别与世界坐标系的原点及 x、y 轴重合，而 z 轴则正好相反，即为垂直屏幕面向内。

在初始状态下，相机在观察坐标系的原点且指向z轴正向，即为垂直屏幕面向内。

```cpp
// 平移变换。
void glTanslate{fd}(TYPE x, TYPE y, TYPE z);

// 旋转变换。
// 绕矢量 v = (x, y, z)T 逆时针方向旋转 angle 指定的角度。旋转角度的范围是 0 ~ 360 度。
void glRotate{fd}(TYPE angle, TYPE x, TYPE y, TYPE z);

// 缩放变换。
void glScale{fd}(TYPE x, TYPE y, TYPE z);
```

变换的顺序：

```cpp
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMultMatrixf(N); /* apply transformation N */
glMultMatrixf(M); /* apply transformation M */
glMultMatrixf(L); /* apply transformation L */
glBegin(GL_POINTS);
glVertex3f(v); /* draw transformed vertex v */
glEnd();

// 在这个过程中，在 GL_MODELVIEW 状态下，相继引入了 I（单位阵），N，M，L 矩阵。

// 变换后的顶点为 NMLv(顶点取列向量)。

// 顶点的变换为 N(M(Lv))，即是先作变换 L，然后是变换 M，最后才是 N。

// 顶点 v 的实际变换顺序正好与指定的顺序相反。
```

（3）投影变换

在调用投影变换命令前必须先在程序中加入下述语句：

```cpp
glMatrixMode(GL_PROJECTION);

glLoadIdentity();
```

这两条命令一方面指定接下来的变换命令只影响投影矩阵，同时也将当前投影矩阵设置为单位阵。

一些函数：

```cpp
// 透视投影。
void gluPerspective(Gldouble fovy, Gldouble aspect, Gldouble zNear, Gldouble zFar);

// 正交投影。
void glOrtho(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top, Gldouble near, Gldouble far);

// 对于二维图形向二维屏幕的投影，则应使用实用库中的如下函数：
// 前面提到过，用二维顶点命令绘制的二维物体的 z 坐标均为零，而 gluOrtho2D() 命令假定场景中的 z 坐标介于 -1.0 和 1.0 之间。
void gluOrtho2D(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top);
```

（4）视口变换

```cpp
// 注意：应该使视口的长宽比与取景体积的长宽比相等，否则会使图像变形。
void glViewport(GLint x, Glint y, Glsizei width, Glsizei height);
```

## 例 10.3

绘制三维空间绘制立方体的程序。

```cpp
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>
#include <stdio.h>


void myinit(void);
void CALLBACK myReshape(int w, int h);
void CALLBACK display(void);


// 初始化
void myinit(void)
{
    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色
    glShadeModel(GL_FLAT);            // 常量明暗处理方式
}

void CALLBACK display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色
    glColor3f(1.0, 1.0, 1.0); // 选当前颜色(R,G,B)为白色
    glLoadIdentity();         // 设置当前矩阵为单位矩阵

    glTranslatef(0.0, 0.0, -3.0); // 平移变换
    glRotatef(45, 1.0, 1.0, 0.0); // 旋转变换
    glScalef(1.0, 2.0, 1.0);      // 缩放变换
    auxWireCube(1.0);             // 绘制立方体
    glFlush();                    // 强制绘图，不驻留缓存
}

void CALLBACK myReshape(int w, int h) // 用于窗口改变大小时的处理，与绘图无关
{
    glMatrixMode(GL_PROJECTION);                              // 指明当前矩阵操作是针对投影矩阵进行的
    glLoadIdentity();                                         // 设置当前矩阵为单位矩阵
    gluPerspective(70.0, (GLfloat)w / (GLfloat)h, 1.5, 40.0); // 投影变换
    glMatrixMode(GL_MODELVIEW);                               // 返回视点-模型矩阵
    glViewport(0, 0, w, h);                                   // 定义视口变换
}


void main(void)
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    // 窗口显示单缓存和RGB(彩色)模式
    auxInitPosition(0, 0, 200, 200);          // 大小 x=200、y=200 ， (0,0)是屏幕左上点
    auxInitWindow(“Perspective 3 - D Cubes”); // 初始化窗口，参数是标题
    myinit();
    auxReshapeFunc(myReshape);
    auxMainLoop(display);
}
```

最终绘制效果如下：

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201527191.png" alt="image-20251111201527191" style="zoom:60%;" />

## OpenGL 状态管理

OpenGL 是一个状态机，应用程序通过 OpenGL 函数调用来实现状态的设置。

OpenGL 的绘图方式是由一系列的状态决定的，如果设置了一种状态或模式而不改变它，OpenGL 在绘图过程中将一直保持这种状态或模式。

OpenGL 总是按照应用程序的发送顺序执行命令。状态影响应该是最接近绘制的状态改变函数来决定。注意：状态改变影响效率。

## 考试参考

### 实例二

画一个三角形和一个正方形。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201944028.png" alt="image-20251111201944028" style="zoom:55%;" />

```cpp
int DrawGLScene(GLvoid)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    glTranslatef(-1.5f, 0.0f, -6.0f);
    glBegin(GL_TRIANGLES);          // 绘制三角形
    glVertex3f(0.0f, 1.0f, 0.0f);   // 上顶点
    glVertex3f(-1.0f, -1.0f, 0.0f); // 左下
    glVertex3f(1.0f, -1.0f, 0.0f);  // 右下
    glEnd();                        // 三角形绘制结束

    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位
    glBegin(GL_QUADS);              // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上
    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下
    glEnd();                        // 正方形绘制结束

    return TRUE;
}
```

### 实例三

着色。

<img src="https://cdn.davidingplus.cn/images/2025/11/11/image-20251111202057148.png" alt="image-20251111202057148" style="zoom:55%;" />

```cpp
int DrawGLScene(GLvoid)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glTranslatef(-1.5f, 0.0f, -6.0f);
    glBegin(GL_TRIANGLES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex3f(0.0f, 1.0f, 0.0f);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex3f(-1.0f, -1.0f, 0.0f);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex3f(1.0f, -1.0f, 0.0f);
    glEnd();

    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位
    glColor3f(0.5f, 0.5f, 1.0f);    // 一次性将当前色设置为蓝色
    glBegin(GL_QUADS);              // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上
    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下
    glEnd();                        // 正方形绘制结束

    return TRUE;
}
```

### 实例四

### 实例五

