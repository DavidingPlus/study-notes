# 迭代任务

1. `LarkSDK-XML`代码走查（抽象，太抽象了）
2. `FileSystem`代码走查（包含`LDir`和`LFileInfo`，暂不包括`LFile`）
   - 该部分的主要工作是重新明确语义，指定重构设计方案，故该部分的内容归纳在一个课题中

# 学习的点

## XmlStream

1. `xml`基础教程链接：[https://www.runoob.com/xml/xml-tutorial.html](https://www.runoob.com/xml/xml-tutorial.html)

2. `xml`中的`CDATA`，参考链接：[https://www.w3school.com.cn/xml/xml_cdata.asp](https://www.w3school.com.cn/xml/xml_cdata.asp)

   - 在`xml`文本中，所有文本均会被解析器解析，但`CDATA`区段的文本会被忽略

   - `CDATA`部分由`<![CDATA[`开始，由`]]>`结束

   - 某些文本里面，需要放非法字符例如`<`和`&`，但是又不能使用转移字符，例如传递**代码片段**，就可以使用`CDATA`区段

     ```xml
     <script>
     <![CDATA[
     function matchwo(a,b)
     {
     if (a < b && a < 0) then
       {
       return 1;
       }
     else
       {
       return 0;
       }
     }
     ]]>
     </script>
     ```

   - 补充：`xml`中预定义的实体引用

     ![image-20240407174259533](https://img-blog.csdnimg.cn/direct/3b455de03242431480407094150c798f.png)

3. `xml Token`，参考链接：[https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html](https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html)

   - 对于一个`xml`文件，可以根据起始标签、内容、结束标签、注释、文档开始、文档结束等，将整个文档进行划分，每个小块就是一个`token`，当游标`cursor`移动的过程中，每个位置就会对应一个`tokenType`

     ![image-20240408113635297](https://img-blog.csdnimg.cn/direct/219efb5dea8748dca8e616e1d6a18198.png)

4. `xml DTD`，参考链接：[https://blog.csdn.net/gavin_john/article/details/51532756](https://blog.csdn.net/gavin_john/article/details/51532756)

   - `xml`的标签是用户自定义的，例如我们可以在标签内嵌套标签，例如`<sport><ball>...</ball></sport>`，在这种情况下`sport`中嵌套的标签肯定不可能是随意的，显然不能放`math`，因此需要一个东西来进行约束，这个东西就是`DTD`文件

   - `DTD`语法

     ```dtd
     <!DOCTYPE note
     [
         <!ELEMENT 班级 (学生+)>
         <!ELEMENT 学生 (名字,年龄,介绍)>
         <!ELEMENT 名字 (#PCDATA)>
         <!ELEMENT 年龄 (#PCDATA)>
         <!ELEMENT 介绍 (#PCDATA)>
     ]>
     ```

   - 在`xml`中引入`DTD`文件，约束此`xml`

     - 引入中写的`SYSTEM`，表示当前的`DTD`文件是本地
     - 如果写的是`PUBLIC`，则表示引入的`DTD`文件是来自于网络

     ```xml
     <?xml version="1.0" encoding="utf-8"?>
     <!--引入dtd文件，约束这个xml-->
     <!DOCTYPE 班级 SYSTEM "myClass.dtd">
     <班级>
         <学生>
             <名字>周小星</名字>    
             <年龄>23</年龄>
             <介绍>学习刻苦</介绍>
         </学生>   
         <学生>
             <名字>林晓</名字> 
             <年龄>25</年龄>
             <介绍>是一个好学生</介绍>
         </学生>   
     </班级>
     ```

5. `xml`中的`PCDATA`

   - `PCDATA`，即`Parsed Character Data`，就是`xml`元素内部解析的文本数据，即作为元素的内容而存在的

6. 关于`std::string`和`std::wstring`的联系

   - `std::string`的底层是`char`，`std::wstring`的底层是`wchar_t`，前者不必多言，后者是代表宽字节，根据平台及编译器的是实现不同可以是`2`字节，也可以是`4`字节，`Linux`下的`gcc`是`4`字节
   - 显然，更多的字节代表可以表示更多的字符集；例如`std::wstring`主要用于`utf-16`的编码字符，`std::string`主要用于存储单字节的字符（`ASCII`），也可以用来保存`utf-8`的字符（注意，这里说的都是主要，当然可以表示其他编码的字符，至于情况如何或者会不会乱码我就不知道了）
   - 关于`unicode`
     - `unicode`统一了所有字符的编码，是一个`Character Set`，也就是字符集
     - **但是`unicode`字符集只是给所有的字符一个唯一编号，却没有具体规定如何用二进制存储**
     - 因此有了不同的存储方式的设计，不同的编码方式就诞生了，最常见的就是`utf-32`，`utf-16`，`utf-8`
     - 具体如何进行编码的，参考链接：[https://blog.csdn.net/hollis_chuang/article/details/110729762](https://blog.csdn.net/hollis_chuang/article/details/110729762)

7. 在`c++`类中定义成员变量是一个引用，参考链接：[https://blog.csdn.net/weixin_42579072/article/details/102618771](https://blog.csdn.net/weixin_42579072/article/details/102618771)

   - 以前听都没听过，今天搜了一下，发现这样在某些情况下，居然还真能通过编译，但是肯定不推荐这么用

   - `c++`类内可以定义引用成员变量，但要遵循以下三个规则：

     - **不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误**
     - **构造函数的形参也必须是引用类型**
     - **不能在构造函数里初始化，必须在初始化列表中进行初始化**

   - **构造函数分为初始化和计算两个阶段，前者对应成员初始化链表，后者对应构造函数函数体。引用必须在初始化阶段，也即在成员初始化链表中完成，否则编译时会报错（引用未初始化）**

   - 测试程序

     ```cpp
     #include <iostream>
     
     class A
     {
     public:
         A(int &target) : a(target)
         {
             std::cout << "构造函数" << std::endl;
         }
         void printA()
         {
             std::cout << "a is: " << a << std::endl;
         }
     
     private:
         int &a;
     };
     int main()
     {
         int a = 20;
         A r(a); // 依旧使用自定义的构造函数
         r.printA();
     
         int &b = a;
         A r1(b);
         r1.printA();
     
         return 0;
     }
     
     ```

   - 执行结果

     ![image-20240409170359574](https://img-blog.csdnimg.cn/direct/1da05573609348d6936e0230ce8bb229.png)

## FileSystem

1. `linux`目录和`windows`目录

   - 目录举例
     - `linux`目录，例如`/usr/bin/../local/bin`，`./abc/../abc`
     - `windows`目录，例如`c:\a\b\..\c`，`.\a\b\..\c`

   - 相同点

     - 都分为绝对路径和相对路径
     - `.`表示本目录，`..`表示上级目录

   - 不同点

     - `windows`的目录名和文件名可以有空格，`linux`不行
     - `windows`下使用的是反斜杠`\`，`linux`使用的是正斜杠`/`
     - `windows`由于具有盘符的概念，在根目录`\`前面有一个盘符的标志，例如`c:`
     - `linux`没有这个概念，最底层的根目录就是`/`

   - 注意，`windows`下在`c/c++`代码中经常会见到在字符串中使用路径，当使用反斜杠的时候，由于反斜杠本身具有特殊含义，是作为转义字符的起始标志，因此需要在前面再加上一个反斜杠代表后面的反斜杠是其原本的意思；而`/`就不会有这个烦恼

     ```cpp
     std::string path = "c:\\abc\\..\def";
     ```

     

# 代码走查问题

## XmlStream

1. 整体代码冗杂，三个类的分工不同，建议放在三个文件中，而不是像现在冗杂放在一个文件中
1. 整体的设计全部都是硬解析，一口气读取所有的数据，然后从头开始以字节为单位进行硬解析；按照目前的规划应当使用开源`expat`库，使用其提供的接口封装成为我们自己的解析器`Parser`，进而衍生出`Reader`和`Writer`

### Parser

由于接口太多了，加上这个代码不用想，肯定是要重构的，因此问题的个数不用那么精确了，由于我怕忘了它的逻辑，所以就把逻辑也放在这里面了（这些逻辑一般都有问题。。。）

1. 代码中的英文字符串前后未与中文字符想间隔一个空格，全篇都是，代码就不放了

   - 同时，代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述

2. 代码中的`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类

3. `.cpp`文件中函数定义的开头总是有一行英文注释，在代码中也是

   ```cpp
   // .cpp
   ...
       
   // low-level - match character and advance cursor.
   bool Parser::parseMatch(const LString chPattern)
   {
       bool bOK = peekMatch(chPattern);
       if (bOK)
           m_iCursor += chPattern.length();
       return bOK;
   }
   
   // get next character - but do not advance cursor.
   LChar Parser::peek()
   {
       if (!eof())
           return m_buffer[m_iCursor];
       return LChar("");
   }
   
   ...
   ```

4. 采用结构体`struct`类型，但是确包含`private`成员，虽然合法，但是很抽象

   ```cpp
   struct Parser
   {
       ...
   
   private:
       // 补充预读缓冲区
       void more();
       // 文档读到末尾标识符
       bool m_bEOF;
       // 预读缓冲器
       std::vector<LChar> m_buffer;
       // 当前缓冲区中的字符数
       size_t m_iBuffer;
   };
   ```

5. `m_buffer`读取的缓冲器建议使用`LByteArray`类型

   ```cpp
   // 预读缓冲器
   std::vector<LChar> m_buffer;
   ```

6. 构造函数可以内联

   - `m_pStream`是`LString`类型，但是却用`nullptr`赋值

   ```cpp
   // .cpp
   Parser::Parser() : 
       m_bEOF(false), m_pStream(nullptr), m_iCursor(0), m_iBuffer(0)
   {
   }
   ```

7. `close()`函数做的是清理的工作，命名不规范

   ```cpp
   // close parsing
   void Parser::close()
   {
       m_pStream = LString();
       m_bEOF = true;
       m_iCursor = 0;
       m_iBuffer = 0;
   }
   ```

8. `peekMatch()`函数参数混乱，有`const LString`，有`const LString*`，应该统一用`const LString&`

   ```cpp
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @param iLen 模式长度引用
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern, size_t &iLen);
   
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern);
   
   /**
    * @brief 匹配字符但不推进光标。
    * @param chPattern 需要匹配的字符
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString chPattern);
   ```

9. `peekMatch`的逻辑混乱，两个函数的逻辑实现不一样

   1. 指针版本

      ```cpp
      // low-level - match text but do not advance cursor.
      bool Parser::peekMatch(const LString *strPattern, size_t &iLen)
      {
          size_t i = 0;
          LString patternCopy = *strPattern; // 创建一个新的LString对象拷贝strPattern
          while (true)
          {
              // 如果 i 超出 patternCopy 的大小，并且下面没有返回 false，则说明匹配成功
              if (i >= patternCopy.length())
              {
                  iLen = i;
                  return true;
              }
      
              // 如果 i 超出当前缓冲区的大小，则调用 more() 函数从 m_stream 中拿去更多的字节
              if ((m_iCursor + i) >= m_iBuffer)
                  more();
      
              // 如果扩充完，i 还超出，就返回 false
              if ((m_iCursor + i) >= m_iBuffer)
                  return false;
      
              // 比较传入的字符串和缓冲区中的内容，如果有一个不满足比较条件则返回 false
              // 一个字节一个字节比。。。
              if (patternCopy.at(i) != LChar(m_buffer[m_iCursor + i]))
                  return false;
      
              i++;
          }
      }
      ```

      - 为什么需要第二个参数`iLen`，并且需要传入引用呢？答案是为`parseMatch()`函数服务

      ```cpp
      // low-level - match text and advance cursor.
      bool Parser::parseMatch(const LString *strPattern, size_t &iLen)
      {
          bool bOK = peekMatch(strPattern, iLen);
          if (bOK)
              m_iCursor += iLen; // 这里需要 iLen 移动游标的位置
          return bOK;
      }
      
      // 剩下两个同理
      ...
      ```

   2. 传值版本

      ```cpp
      bool Parser::peekMatch(const LString chPattern)
      {
          bool match = false;
          int n = chPattern.length();
      
          LString now;
          for (int i = 0; i < n; i++)
          {
              // 把缓存中的比较字符串拷贝到 now 中，还是一个一个拷贝，然后进行比较
              // 和前面对比而言，这样写 i 如果超出 m_buffer 边界就会出问题了
              now.append(m_buffer[m_iCursor + i]);
          }
          match = now == chPattern;
      
          return !eof() && m_iCursor < m_iBuffer && match;
      }
      ```

10. `consume()`函数命名不规范，并且逻辑有误

       - 第一，名字为啥叫`consume`，这和前进有啥关系嘛？

       - 返回了`bool`值，但是在整个文件中，并没有找到一处使用了这个返回值，这倒没什么；其次，`m_iCursor`超出边界以后，返回`false`，为什么不把`m_iCursor`重置到原来的位置呢？

    ```cpp
    // consume count characters.
    bool Parser::consume(size_t iCount)
    {
        size_t iRemains = m_iBuffer - m_iCursor;
        if (iRemains < iCount) // 如果剩下的长度小于想前进的长度，则补充缓冲区内容
            more();
        m_iCursor += iCount;
        return m_iCursor <= m_iBuffer;
    }
    ```

11. 接口逻辑：`readText()`和`readCDATAText()`

    ```cpp
    // consume characters up to the delimiter.
    bool Parser::readText(LString &strText, char chDelimiter)
    {
        // 查看是否到达末尾
        while (!eof())
        {
            // 一个一个字符的判断，考虑了跳过 CDATA 段的逻辑
            readCDATAText(strText);
            LChar ch = peek();
            if (ch == LChar(chDelimiter))
            {
                return true;
            }
            // 加入 strText 。。。
            strText.append(LChar(ch));
            consume(1);
        }
        return strText.length() > 0;
    }
    
    bool Parser::readCDATAText(LString &strText)
    {
        // 匹配 CDATA 段起始
        if (peekMatch(LString("<![CDATA[")))
        {
            consume(9); // Consume "<![CDATA["
            // 匹配 CDATA 段结束
            while (!peekMatch(LString("]]>")))
            {
                strText.append(peek());
                consume(1);
            }
            // End of CDATA block
            consume(3); // Consume "]]>"
            return true;
        }
        return false;
    }
    ```

12. 接口逻辑：`skipSpace()`

    ```cpp
    // skips / consumes whitespace.
    int Parser::skipSpace()
    {
        int res = 0;
        // 循环匹配这些字符，然后跳过
        while (peekMatch(LString("\t")) || peekMatch(LString("\r")) || peekMatch(LString("\n")))
        {
            res++;
            consume(1);
        }
        // （原注释）有点奇怪 一起放上面会有问题 会有时match上不该match的东西
        // peekMatch 写的，一言难尽，所以才出现了这种问题
        while (peekMatch(LString(" ")))
        {
            res++;
            consume(1);
        }
        return res;
    }
    ```

13. 接口逻辑：`more()`

    - 这个类里面的冗杂代码和边界条件的代码太多了，不放完整代码了

    - 第一步：将`buffer`中`cursor`以后的部分移动到`buffer`头部

    ```cpp
    // unprocessed data in buffer.
    size_t iCarry = m_iBuffer - m_iCursor;
    // left over data?
    if (iCarry > 0)
    {
        // yes: carry forward unprocessed data.
        LChar *buf = &m_buffer[0];
        memcpy(buf, buf + m_iCursor, iCarry);
    }
    // reset cursor to start of buffer.
    // 不需重置?
    // 对啊，这里注释也写了，为什么不需重置？
    // m_iCursor = 0;
    ```

    - 示意图：

      <img src="https://img-blog.csdnimg.cn/direct/cb14624051954d9a916c0a0e02136c9a.png" alt="image-20240408095910960" style="zoom:75%;" />

    - 第二步：从`m_pStream`中读取内容

    ```cpp
    // 全都进来，what？？？？结合Reader，是一口气把文件的所有内容读进来，如果太大了怎么办
    // 其次，按照这个逻辑，红色部分的内容还没有被读取，直接就从 0 开始赋值？
    for (int i = 0; i < m_pStream.length(); i++)
    {
        ch = m_pStream.at(i);
        m_buffer[i] = ch;
    }
    ```

### LXmlReader

1. 代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述

2. 代码中的`std::pair`，`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类

3. `LEntry`元素实体结构，完全没有注释，根本不知道里面的成员变量是什么意思

   - 我只能猜测了
     - `m_element`：元素内容
     - `m_children`：是否具有子元素
     - `m_skipped`：结合成员变量`m_iSkipped`是整个文档跳过的子元素个数，推断为在该元素实体内跳过的子元素个数
     - `m_iComment`：元素内部注释内容
     - `m_commentIndex`：根据`getComment()`函数可以猜测是当前注释的字符偏移量，也就是游标`curSor`

   ```cpp
   /**
    * @struct LEntry
    * @brief 元素实体，维护元素内容数据。
    */
   struct LEntry
   {
       LString m_element;
       bool m_children;
       size_t m_skipped;
       LString m_iComment;
       LString m_commentIndex;
   
       LEntry() : m_children(false), m_skipped(0){};
       LEntry(const LEntry &copy)
           : m_children(copy.m_children), m_element(copy.m_element), m_skipped(copy.m_skipped){};
   };
   ```

4. 成员变量文档版本信息`m_nowVersion`在源文件中没有使用，可以删除

   ```cpp
   // xml文档版本信息
   LString m_nowVersion;
   LString m_Version;
   ```

5. `m_attributes`和`m_attributes2`一个使用`STL`的容器，一个使用`SDK`的容器，应统一

   ```cpp
   // 最近的 XML 元素的属性列表。
   std::list<std::pair<LString, LString>> m_attributes;
   LList<LPair<LString, LString>> m_attributes2;
   ```

6. 所有的构造函数通过初始化序列初始化成员变量，但是在函数体中又重复做了一次

   ```cpp
   // 默认构造
   LXmlReader::LXmlReader() : m_bStart(false), m_iSkipped(0)
   {
       // 这里又重复赋值一次
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open("");
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   // 其他的同理
   ...
   ```

7. 构造函数的使用参数`const LString&`，`const LByteArray&`，`const char*`时，可以代码复用，但是目前的实现冗杂

   ```cpp
   LXmlReader::LXmlReader(const LString &inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open(inputStream);
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   LXmlReader::LXmlReader(const LByteArray &inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open(inputStream.toString());
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   LXmlReader::LXmlReader(const char *inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       LString now(inputStream);
       bool open = m_parser.open(now);
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   ```

8. `LXmlReader`通过传入`LFile&`参数构造读取器的时候，将整个文件的所有内容一次性读进来，放入`m_parser`中

   - 按照`expat`库的思路，应该是通过流式进行处理，例如读取一行处理一行，这样能够避免在内存中开辟过大的内存，这才是`stream`，而不是`tree`

   ```cpp
   LXmlReader::LXmlReader(LFile &inputStream) : m_bStart(false), m_iSkipped(0)
   {
   	...
           
       LString file;
       while (!inputStream.end())
       {
           file.append(inputStream.readLine().toString());
       }
   
       bool open = m_parser.open(file);
       if (!open)
       {
           std::cout << "构造失败" << std::endl;
       }
   	...
   }
   ```

9. `addData()`接口同样可以复用，同构造函数

   - 并且函数可以内联

   ```cpp
   void LXmlReader::addData(const LString &data)
   {
       m_parser.m_pStream.append(data);
   }
   
   void LXmlReader::addData(const LByteArray &data)
   {
       m_parser.m_pStream.append(data.toString());
   }
   
   void LXmlReader::addData(const char *data)
   {
       m_parser.m_pStream.append(data);
   }
   ```

10. 接口逻辑：`parseToken()`

       - 局部变量`upIndex`没有什么作用

    ```cpp
    // parse a token
    bool LXmlReader::parseToken(LString &strToken)
    {
        LChar ch = m_parser.peek();
        LString nowString;
        int upIndex = 0;
        //?? 是否需要ch>=0
        // 一个字符一个字符判断，目的是卡好一个 token 的范围（至于功能上能不能卡好我也无从验证）
        while (ch != LChar('=') && ch != LChar('/') && ch != LChar('>') && ch != LChar('"') && ch != LChar(' ') && ch != LChar('\''))
        {
            nowString.append(ch);
            m_parser.consume(1);
            upIndex++;
            ch = m_parser.peek();
        }
        strToken = nowString;
        return strToken.length() > 0;
    }
    ```

    - 为什么传递参数`strToken`，还是引用？最后返回的还是一个`bool`值；单从本函数的逻辑上来看，完全可以将`nowString`返回，如果为空就代表失败

         - 查看了`parseToken()`调用的地方，就明白了，在源文件中有两处
         - 无非就想把解析出的结果记录在`element`或者`pair`中，那直接用返回值记录啊
    
    ```cpp
    // returns true start of an element is successfully consumed.
    // if true, the element's attributes are available below through getAttribute.
    bool LXmlReader::readStartElement()
    {
        LEntry element;
        if (isStartElement() && parseToken(element.m_element))
        {
           ...
        }
        
        ...
    }
    
    // parse attribute=quoted-value sequence.
    bool LXmlReader::parseAttribute()
    {
        std::pair<LString, LString> pair;
        bool bOK = skipspace(true) && parseToken(pair.first);
        
        ...
    }
    ```

11. 接口逻辑：`skipspace()`

    - 接口命名不规范，应使用小驼峰`skipSpace`
    - 参数`bInside`：判断是在元素声明内还是外部
      - 在内部，跳过空格、注释等非正文内容，直到遇到正文内容或其他标记为止
      - 在外部，除了上面的内容，还会处理一些文档声明，例如`XML`版本，编码信息，`DTD`声明等
    - 这里面的所有匹配都是硬匹配的，这个函数就是一个非常经典的例子，单从匹配的角度来讲，可以考虑正则表达式而不是硬匹配
    - 在内部处理注释的时候，应匹配注释开始`<!--`和注释结束`-->`而不是`--`
    - `TODO`：`bInside`为`false`的时候处理注释的逻辑目前看不懂

    ```cpp
    // skips / consumes whitespace.
    // bInside - true if inside an element declaration eg. between '<' and '>'.
    bool LXmlReader::skipspace(bool bInside)
    {
        if (bInside)
        {
            while (true)
            {
                // 1. 匹配空格
                m_parser.skipSpace();
                // 2. 匹配注释
                if (m_parser.peekMatch("--"))
                {
                    m_parser.consume(2);
                    // 在注释内部，跳过注释内容
                    while (!m_parser.eof() && !m_parser.peekMatch("--"))
                        m_parser.consume(1);
                    // 匹配到注释结尾
                    if (m_parser.peekMatch("--"))
                        m_parser.consume(2);
                }
                else
                    break;
            }
        }
        else
        {
            while (true)
            {
                // 1. 匹配空格
                m_parser.skipSpace();
                // 2. 匹配注释
                // 基本逻辑和上面是一样的，但是这里多了很多成员变量的修改
                // 下面关于 m_Comment 和 m_stack 目前看不懂
                if (m_parser.peekMatch("<!--"))
                {
                    bool flag1 = (m_stack.size() != 0);
                    m_parser.consume(4);
                    if (flag1)
                        m_stack.back().m_iComment = LString("");
                    m_Comment = LString("");
                    while (!m_parser.eof() && !m_parser.peekMatch("-->"))
                    {
                        if (flag1)
                            m_stack.back().m_iComment.append(m_parser.peek());
                        m_Comment.append(m_parser.peek());
                        m_parser.consume(1);
                    }
                    if (m_parser.peekMatch("-->"))
                        m_parser.consume(3);
                    // m_stack.back().m_iComment.append(LString(" "));
                    m_parser.skipSpace();
                    if (flag1)
                        m_stack.back().m_commentIndex = LString::fromInt(characterOffset());
                }
                // 3. 匹配版本号和编码信息
                // <?xml version="1.0" encoding="utf-8"?> 匹配固定模式，逻辑固定
                else if (m_parser.peekMatch("<?"))
                {
                    m_parser.consume(2);
                    while (!m_parser.eof() && !m_parser.peekMatch("?>"))
                    {
                        // 获取版本信息
                        if (m_parser.peekMatch("version"))
                        {
                            ...
                        }
                        // 获取编码信息
                        else if (m_parser.peekMatch("encoding"))
                        {
                            ...
                        }
                    }
                    if (m_parser.peekMatch("?>"))
                        m_parser.consume(2);
                }
                // 3. 匹配 DTD 声明
                // <!DOCTYPE 班级 SYSTEM "myClass.dtd"> 匹配固定模式，逻辑固定
                else if (m_parser.peekMatch("<!DOCTYPE"))
                {
                   ...
                }
                else
                    break;
            }
        }
        return true;
    }
    ```

12. 接口逻辑：`parseAttribute()`

    - 关于`m_attributes`和`m_attributes2`，上面提到过，一个用的是`STL`，一个用的是`SDK`，但是在这里两个东西存储的数据是一模一样的，因此有理由怀疑这两个东西其实是一个东西，可以删除一个

    ```cpp
    // parse attribute=quoted-value sequence.
    bool LXmlReader::parseAttribute()
    {
        std::pair<LString, LString> pair;
        // 跳过空格并且解析 key
        bool bOK = skipspace(true) && parseToken(pair.first);
        if (bOK)
        {
            // 解析 = 号
            bool FLag1 = skipspace(true) && m_parser.parseMatch(LString("=")) && skipspace(true);
            // 由于属性可能被单引号或者双引号扩充起来，因此两个都进行判断
            // 由于 parseMatch 只有成功才会修改游标 curSor，因此这里的逻辑是没问题的
            bool Flag2 = m_parser.parseMatch(LString("\'")) && m_parser.readText(pair.second, '\'') && m_parser.parseMatch(LString("\'"));
            bool Flag3 = m_parser.parseMatch(LString("\"")) && m_parser.readText(pair.second, '"') && m_parser.parseMatch(LString("\""));
            bOK = FLag1 && (Flag2 || Flag3);
            if (bOK)
            {
                m_attributes.push_back(pair);
                LPair<LString, LString> pair2;
                pair2.key() = pair.first;
                pair2.value() = pair.second;
                m_attributes2.append(pair2);
            }
        }
        return bOK;
    }
    ```

13. 接口逻辑：`readStartElement()`

    - 两个重载版本，第一个的参数应该用`const LString&`
    - 当前元素是否具有子元素`m_children`，代码中是直接判断是能否解析到`>`，从这个函数来看，这个逻辑是不合理的，应该判断这个起始标签的下一个位置是不是子元素的起始标签，这样才是合理的

    ```cpp
    // returns true if start of named element is successfully consumed.
    // if true, the element's attributes are available below through getAttribute.
    bool LXmlReader::readStartElement(const LString *strElement)
    {
        LEntry element;
        size_t iLen = 0;
        // 如果传入字符串为空，则失败
        if (strElement == nullptr || strElement->isEmpty())
            return false;
        // 判断当前是否为起始标签，并且是否能够成功解析
        if (isStartElement() && m_parser.parseMatch(strElement, iLen))
        {
            // element.Element.assign(strElement, iLen);
            //??
            LString a = *strElement;
            // 修改元素实体的内容
            element.m_element = a.substr(0, iLen);
            // 修改属性
            m_attributes.clear();
            m_attributes2.clear();
            while (parseAttribute())
                ;
            // 记录当前元素是否具有子元素，这个逻辑不对吧。。
            element.m_children = m_parser.parseMatch(LString(">"));
            // 加入嵌套的栈
            m_stack.push_back(element);
            m_bStart = false;
            return true;
        }
        return false;
    }
    
    // returns true start of an element is successfully consumed.
    // if true, the element's attributes are available below through getAttribute.
    bool LXmlReader::readStartElement()
    {
        // 思路和前面基本一致
        LEntry element;
        // 只是这里改为直接解析 token 去了
        if (isStartElement() && parseToken(element.m_element))
        {
            m_attributes.clear();
            m_attributes2.clear();
            while (parseAttribute())
                ;
            element.m_children = m_parser.parseMatch(LString(">"));
            m_stack.push_back(element);
            m_bStart = false;
            return true;
        }
        return false;
    }
    ```

14. 接口逻辑：`isStartElement()`

    - `TODO`：第一个函数的逻辑目前看不懂。。。
    - 第二个重载版本的参数同理应当使用`const LString&`

    ```cpp
    // returns true if start of an element.
    bool LXmlReader::isStartElement()
    {
        // 看不懂。。。
    	...
    }
    
    // returns true if start of the named element.
    bool LXmlReader::isStartElement(const LString *strElement)
    {
        if (strElement == nullptr)
            return false;
        return isStartElement() && m_parser.peekMatch(strElement);
    }
    ```

15. 接口逻辑：`readUntilElement()`

    - 参数同理应当使用`const LString&`
    - 一来就来了一个`new`，我了个豆。。。
    - `AllStream`，把目前缓冲区里面的数据全拿出来？？？

    ```cpp
    bool LXmlReader::readUntilElement(const LString strElement)
    {
        LString *s = new LString(strElement);
        // 枚举了三种不同的标签
        // 第三种代表了一个自闭合的标签，表示该元素存在但是没有内容
        // <element ...>，<element>，<element/>
        LString now("<");
        now.append(strElement);
        now.append(" ");
        LString now1("<");
        now1.append(strElement);
        now1.append(">");
        LString now2("<");
        now2.append(strElement);
        now2.append("/>");
        // 判断是否读取到末尾
        while (!atEnd())
        {
            LString AllStream = m_parser.getBuffer();
            // 查找是否含有上面三种模式的标签
            if (AllStream.contains(now) || AllStream.contains(now1) || AllStream.contains(now2))
            {
                // 如果当前游标位置的标签是目标标签，读取并返回 true
                if (isStartElement(s))
                {
                    readStartElement();
                    return true;
                }
                // 又开始顺着刚才的位置读，读取（跳过）自由节点的内容
                readStartElement();
                readPCData();
                if (readEndElement(false))
                {
                    // 如果读到了返回 true，否则循环再来。。。
                    if (readStartElement(s))
                        return true;
                }
            }
            else
                return false;
        }
        return false;
    }
    ```

16. 接口逻辑：`isEndElement()`

    - 一个元素就算没有子元素，也可以自身有内容啊，不一定就是自闭合标签，例如`<book>math</book>`

    ```cpp
    // returns true if current element is self-closing OR no more nested content remains
    // eg. cursor is positioned at the closing tag.
    bool LXmlReader::isEndElement()
    {
        if (m_stack.size() > 0)
        {
            // 查看该元素是否具有子元素
            bool bChildren = m_stack.back().m_children;
            skipspace(!bChildren);
            if (bChildren)
            {
                // 有子元素则取匹配子元素
                LString strTail;
                strTail = "</";
                strTail.append(m_stack.back().m_element);
                strTail.append(">");
                return m_parser.peekMatch(strTail);
            }
            // 没有则匹配自闭合？？？这里逻辑感觉不对
            return m_parser.peekMatch("/>");
        }
        return false;
    }
    ```

17. 接口逻辑：`readEndElement()`

    - 三个重载版本，第二个重载版本参数应使用`const LString&`

    ```cpp
    bool LXmlReader::readEndElement(bool bSkip, const LString *element)
    {
        if (element == nullptr)
            return false;
        return m_stack.size() &&
               m_stack.back().m_element == (*element) &&
               readEndElement(bSkip);
    }
    
    // conclude self-closing element OR consume closing element.
    bool LXmlReader::readEndElement(bool bSkip)
    {
        bool bOK = false;
        int startSkip = m_iSkipped;
        if (m_stack.size() > 0)
        {
            // 判断是否存在子元素
            bool bChildren = m_stack.back().m_children;
            skipspace(!bChildren);
            if (bChildren)
            {
                LString strTail;
                strTail = "</";
                strTail.append(m_stack.back().m_element);
                strTail.append(">");
                // 不存在结尾元素，则返回 false
                LString buffer = m_parser.getBuffer();
                if (!buffer.contains(strTail))
                    return false;
                // 否则就开始循环查找末尾元素标签
                // 循环里面的逻辑没看懂。。。
                do
                {
                    bOK = m_parser.parseMatch(strTail);
                    if (!bOK && bSkip)
                    {
                        // what the hell is doing here？？？
                        readPCData();
                        if (readStartElement())
                        {
                            m_stack.back().m_skipped++;
                            m_iSkipped++;
                            getElementName();
                            readPCData();
                            readEndElement();
                            readPCData();
                        }
                        // else break;
                    }
                    else
                        break;
                } while (!bOK && !m_parser.eof());
            }
            // 没有子元素就匹配自闭合？？？又匹配自闭合？？？
            else
                bOK = m_parser.parseMatch("/>");
            if (bOK)
            {
                nowSkip = m_iSkipped - startSkip;
                m_stack.pop_back();
            }
        }
        if (m_parser.eof())
        {
            std::cout << "已读到末尾。" << std::endl;
        }
        return bOK;
    }
    
    void LXmlReader::readEndElement()
    {
        // 和第二个重载代码结构类似
        ...
    }
    ```

18. 接口`readEndEleName()`，和`readEndElement()`功能类似，可以复用

    - 一个返回解析的元素名，一个返回是否解析成功，完全可以复用

    ```cpp
    /**
     * @brief 解析结束标签（end element）
     * @param bSkip 控制是否跳过再解析，当 bSkip 为 true时，若解析当前标签的结束标签失败，则会跳过中间子节点直到解析到当前标签的结束标签；
     * 如果bSkip为false，则表示要继续解析子节点，而不跳过内容。
     * @return 如果函数返回 true，则表示找到了结束元素；如果函数返回 false，则表示没有找到当前标签的结束标签。
     */
    bool readEndElement(bool bSkip);
    
    /**
     * @brief 解析结束标签并返回当前解析元素名
     * @param bSkip 控制是否跳过再解析，当 bSkip 为 true时，若解析当前标签的结束标签失败，则会跳过中间子节点直到解析到当前标签的结束标签；
     * 如果bSkip为false，则表示要继续解析子节点，而不跳过内容。
     * @return 如果函数返回不为空的节点名，则表示找到了结束元素；如果函数返回空LString，则表示没有找到当前标签的结束标签。
     */
    LString readEndEleName(bool bSkip);
    ```

19. 接口逻辑：`readUntilEndEle()`

    - `readUntilElement()`是碰到这个标签就可以了，`readUntilEndEle()`还需要这个标签是结束标签
    - 参数应使用`const LString&`

    ```cpp
    bool LXmlReader::readUntilEndEle(const LString element)
    {
        if (element.isEmpty())
            return false;
        // 不存在结尾元素
        LString strTail("</");
        strTail.append(element);
        strTail.append(">");
        // 又来了，又是经典的 getBuffer()
        LString buffer = m_parser.getBuffer();
        if (!buffer.contains(strTail))
            return false;
        // 从栈里面取出一个一个的元素，去和给定的值比较
        bool Flag = false;
        if (m_stack.size() > 0)
        {
            for (const auto &ele : m_stack)
            {
                if (ele.m_element == element)
                    Flag = true;
            }
        }
        // 如果有，就开始循环读取，直到找到目标
        if (Flag)
        {
            while (m_stack.back().m_element != element)
            {
                readEndElement();
            }
            readEndElement();
            return true;
        }
        return false;
    }
    ```

20. 接口逻辑：`readPCData()`

    - `readPCDataW`()是返回`std::wstring`的版本
      - 目前两个函数的实现分开，可以复用，通过标准的`LString`进行中转，然后各自导出为`std::string`和`std::wstring`
    - 函数声明中提到自由文本节点的概念，但是官方好像并没有这个概念，这样是否合理？

    ```cpp
    /**
     * @brief 检索元素下的PC数据（即自由文本节点）
     * @return 返回获取的PC数据，若为空则未获取到PC数据
     */
    LString readPCData();
    ```

    - 函数定义

    ```cpp
    // retrieve PC Data (free text nodes under an element).
    LString LXmlReader::readPCData()
    {
        LString strData;
        if (m_stack.size() > 0 && m_stack.back().m_children)
        {
            bool bOK = false;
            LString strText;
            // strText.reserve(128);
            // 通过 Parser 的 readText() 函数从 < 开始读取文本内容
            bOK = m_parser.readText(strText, '<');
            if (bOK)
                // 处理文本实体引用
                readEntities(strText, strData);
            // //未读取到pcdata
            // if(strText.isEmpty()) bOK = false;
        }
        return strData;
    }
    ```

21. 接口逻辑：`readStringElement()`

    - `readStringElementW()`是该函数返回`std::wstring`的版本
      - 问题同上
    
    ```cpp
    // read text content: assumes element with text only - no child elements.
    LString LXmlReader::readStringElement(const LString *strElement)
    {
        LString res;
        LString now(*strElement);
        int nowIndex = characterOffset();
        // 如果现在读取的标签（m_stringName) 和传入参数匹配
        if (m_stringName == *strElement)
        {
            // 读取文本内容
            res = readPCData();
            // 读取标签末尾
            if (readEndElement(false, &res))
                return res;
            return LString("");
        }
        // 不匹配则一直读取直到找到目标
        else if (readUntilElement(now))
        {
            // 逻辑同上
            res = readPCData();
            if (readEndElement(false, strElement))
            {
                return res;
            }
            else
            {
                // 获取预前进光标数，将光标退回
                int upIndex = characterOffset() - nowIndex;
                m_parser.m_iCursor = m_parser.m_iCursor - upIndex;
                res = LString("");
                return res;
            }
        }
        return res;
    }
    ```

22. `getAttribute()`和`getAttributeW()`同样可以复用

    ```cpp
    // retrieve text for the named attribute.
    LString LXmlReader::getAttribute(const LString *strAttribute)
    {
        // strValue.resize(0);
        LString strValue;
        if (strAttribute == nullptr)
            return strValue;
        // 遍历 m_attributes 获得结果
        std::list<std::pair<LString, LString>>::const_iterator it = m_attributes.begin();
        while (it != m_attributes.end())
        {
            if ((*it).first == (*strAttribute))
            {
                // expand entities only when value is requested.
                // 实体引用的转换
                readEntities((*it).second, strValue);
                return strValue;
            }
            it++;
        }
        return LString("");
    }
    
    // 另一个的逻辑一摸一样
    ```

23. `enumAttributes()`接口不知道设计的目的是什么，经全局搜索也没有在其他接口中使用到

    ```cpp
    // begin/end iterators for current element's attributes.
    bool LXmlReader::enumAttributes(LList<LPair<LString, LString>>::iterator &itBegin, LList<LPair<LString, LString>>::iterator &itEnd)
    {
        // itBegin = m_attributes.begin();
        // itEnd = m_attributes.end();
        // return m_attributes.size() > 0;
        LList<LPair<LString, LString>>::iterator m_begin(m_attributes2.begin());
        LList<LPair<LString, LString>>::iterator m_end(m_attributes2.end());
        // 把成员变量的首尾迭代器赋值给参数？？？
        itBegin = m_begin;
        itEnd = m_end;
        // itBegin = m_attributes.begin();
        // itEnd = m_attributes.end();
        // 有数据就返回 true ？？？
        return m_attributes.size() > 0;
    }
    ```

24. 接口逻辑：`getComment()`

    - `b.toInt()`这一样没有用，可以删去

    ```cpp
    LString LXmlReader::getComment()
    {
        // 防止影响其他接口
        if (m_stack.size() == 0)
            return LString("");
        skipspace(false);
        if (m_stack.size() > 0 && !m_stack.back().m_iComment.isEmpty())
        {
            // 判断当前偏移量和 m_stack 中记录的偏移量是否一致
            LString a = LString::fromInt(characterOffset());
            LString b = m_stack.back().m_commentIndex;
            b.toInt();
            if (a.toInt() == b.toInt())
            {
                // 获取注释内容
                LString now = m_stack.back().m_iComment;
                now.trim();
                return now;
            }
        }
        return LString("");
    }
    ```

### LXmlWriter

1. 代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述

2. 成员变量`m_pStream`是一个引用（？？？），或许有这种用法，但是肯定不是在这里

   ```cpp
   // 输入流内容
   LString &m_pStream;
   ```

3. 成员变量嵌套元素的栈应使用`LStack`类型

   - 等等，前面是`std::stack`，这里又是`std::vector`？？

   ```cpp
   // 嵌套元素的堆栈。
   std::vector<LEntry> m_stack;
   ```

4. 接口逻辑：`adopt`()

   - `TODO`：没看懂。。。

   ```cpp
   void LXmlWriter::adopt()
   {
       if (m_stack.size() && !m_stack.back().m_children)
       {
           m_stack.back().m_children = true;
           writeString(">");
           writeString("\n");
       }
   }
   ```

5. `writeString()`接口，提供了多个重载版本，但是均可以做到复用，可通过`LString`进行统一

   - 下面的做法都是将封装类型`LString`或者`std::wstring`转化为基础类型`const char*`和`const wchar_t`*在插入，个人认为虽然可行但不优雅，应像上面所说使用`LString`进行统一

   ```cpp
   void LXmlWriter::writeString(const char *strText)
   {
       // size_t iLen = strlen(strText);
       // size_t iWrote = 0;
       // m_pStream->Write((unsigned char *)strText, iLen, iWrote);
       m_pStream.append(strText);
   }
   
   void LXmlWriter::writeString(const wchar_t *strText)
   {
       std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
       std::string strTran = converter.to_bytes(strText);
       writeString(strTran.c_str());
   }
   
   void LXmlWriter::writeString(const LString &strText)
   {
       // 不是哥，你数据的类型是 LString ，你插入 LString 还先转化为 const char* ？？？
       writeString(strText.toStdString().c_str());
   }
   
   void LXmlWriter::writeString(std::wstring &strText)
   {
       writeString(strText.c_str());
   }
   ```

6. `writeAttributeRaw()`和`writeAttribute()`函数

   - `writeAttributeRaw()`的参数应使用`const LString&`
   - 观察了这两个函数可以发现，`writeAttributeRaw()`函数是`writeAttribute()`函数实际做写入操作的函数
   - 并且经过全局搜索后发现`writeAttributeRaw()`函数只在`writeAttribute()`函数中被调用，`writeAttribute()`其实是有很多重载版本
   - 那么完全可以将`writeAttributeRaw()`函数合并到`writeAttribute()`中，做一个基础版本的`writeAttribute()`，比如就是`LString`，其他的重载都复用该版本即可
   - 目前的重载版本只留了一个`LString`，其他的版本均注释掉，后续应考虑撤销注释

   ```cpp
   bool LXmlWriter::writeAttributeRaw(const LString *strAttribute, const LString *strValue)
   {
       // 真正调用 writeString() 做写入操作的函数
       if (strAttribute == nullptr || strValue == nullptr)
       {
           return false;
       }
       writeString(" ");
       writeString(*strAttribute);
       writeString("=\"");
       writeString(*strValue);
       writeString("\"");
       return true;
   }
   
   bool LXmlWriter::writeAttribute(const LString &strAttribute, const LString &strValue)
   {
       // 先做一些合法性的判断，然后调用 writeAttributeRaw() 进行实际的写入操作
       // 判空
       if (strAttribute.isEmpty() || strValue.isEmpty())
       {
           std::cout << "写入属性不能为空" << std::endl;
           return false;
       }
       // 判断写入格式是否正确
       if (!rightForm(strAttribute))
       {
           std::cout << "写入格式错误,写入" << strAttribute << "失败" << std::endl;
           return false;
       }
       std::string strEntity;
       // 将特殊符号替换为其对应的实体引用
       insertEntities(strValue.toStdString().c_str(), strEntity);
       const LString valueStr(strEntity);
       // insertEntities(strValue, strEntity);
       // return writeAttributeRaw(strAttribute, strEntity.c_str());
       return writeAttributeRaw(&strAttribute, &valueStr);
   }
   ```

7. 构造函数的实现

   - `m_pStream`是一个`LString`，初始化先`new`一个`LString`，再解引用，然后赋值？？？
   - 参数中`LString&`，`LByteArray&`，`LFile&`均是左值引用，应当加上`const`以保证能够传入`value`

   ```cpp
   LXmlWriter::LXmlWriter() : m_pStream(*(new LString(""))) {}
   
   LXmlWriter::LXmlWriter(LString &inputStream) : m_pStream(inputStream) {}
   
   LXmlWriter::LXmlWriter(LByteArray &inputStream) : m_pStream(*(new LString("")))
   {
       m_pStream = inputStream.toString();
   }
   
   LXmlWriter::LXmlWriter(const char *inputStream) : m_pStream(*(new LString(inputStream))) {}
   
   LXmlWriter::LXmlWriter(LFile &inputStream) : m_pStream(*(new LString("")))
   {
       if (!inputStream.exists())
       {
           std::cout << "文件不存在" << std::endl;
       }
   
       inputStream.open(LFile::OpenMode::ReadOnly | LFile::OpenMode::Text);
       LString file;
       while (!inputStream.end())
       {
           file.append(inputStream.readLine().toString());
       }
       m_pStream = file; // 绑定引用成员变量与传入的对象
   }
   ```

8. 接口逻辑：`writeStartElement()`

   ```cpp
   bool LXmlWriter::writeStartElement(const LString &strElement)
   {
       // 判空
       if (strElement.isEmpty())
           return false;
       // 检查写入的值是否符合规范
       if (!rightForm(strElement))
       {
           std::cout << "写入格式错误,写入" << strElement << "失败" << std::endl;
           return false;
       }
       LEntry e;
       e.m_element = strElement;
       // call before pushing new element onto stack.
       adopt();
       m_stack.push_back(e);
       // 执行写入操作
       writeString("<");
       writeString(strElement);
       return true;
   }
   ```

9. 接口逻辑：`writeEndElement()`

   ```cpp
   bool LXmlWriter::writeEndElement()
   {
       if (m_stack.size())
       {
           if (m_stack.back().m_children)
           {
               // 写入一个标签
               writeString("</");
               writeString(m_stack.back().m_element.toStdString().c_str());
               writeString(">\n");
           }
           else
               // 没有子元素，又写入自闭合标签？？？
               writeString(" />\n");
           m_stack.pop_back();
           return true;
       }
       return false;
   }
   ```

10. 接口逻辑：`writeStringElement()`

    - 两个重载版本，一个带属性s，一个不带属性
         - 解释一下四个参数的含义
           - `strElement`：元素标签名
           - `strValue`：元素文本内容
           - `attributeName`：属性名
           - `attributeValue`：属性内容
    - 属性内容这里给的是泛型`T`，但是在函数内部写入的时候给他当成`LString`直接用了，这是不合理的，可以提供多个版本的重载，或者规定只能传入`LSring`，把数据类型转换的问题交给用户

    ```cpp
    template <typename T>
    bool LXmlWriter::writeStringElement(const LString &strElement, const LString &strValue,
                                        const LString &attributeName, T attributeValue)
    {
        // 判空
        if (strElement.isEmpty())
        {
            std::cout << "元素名为空，写入失败" << std::endl;
            return false;
        }
        if (attributeName.isEmpty())
        {
            std::cout << "写入属性名为空，写入失败" << std::endl;
            return false;
        }
        // 判断格式是否正确
        if (!rightForm(strElement))
        {
            std::cout << "写入格式错误，写入失败";
            return false;
        }
        adopt();
        // 写入起始标签
        writeString("<");
        writeString(strElement);
    
        // 写入属性
        if (!attributeName.isEmpty())
        {
            // 这个函数目前只有两个参数都是 LString 的重载版本，就直接把 T 类型的属性值当成 LString 传进去了？？？
            writeAttribute(attributeName, attributeValue);
        }
    
        writeString(">");
    
        // 写入文本内容
        writeString(strValue);
    
        // 写入结束标签
        writeString("</");
        writeString(strElement);
        writeString(">\n");
        return true;
    }
    
    bool LXmlWriter::writeStringElement(const LString &strElement, const LString &strValue)
    {
        // 逻辑类似
        ...
    }
    ```

11. 接口逻辑：`writePCData()`

    ```cpp
    bool LXmlWriter::writePCData(const LString &strPCData)
    {
        // 判空
        if (strPCData.isEmpty())
        {
            std::cout << "写入内容为空" << std::endl;
            return false;
        }
        std::string strEntity;
        // insertEntities(strPCData, strEntity);
        // 字符的实体引用替换
        insertEntities(strPCData.toStdString().c_str(), strEntity);
        adopt();
        // 写入内容
        writeString(strEntity.c_str());
        writeString("\n");
        return true;
    }
    ```

12. 接口逻辑：`writeComment()`和`writeCommentOrigin()`

    - 二者都是写入注释，只不过前者要求输入的是标准格式的注释，后者是输入的是纯注释内容

    ```cpp
    // 要求输入标准格式
    bool LXmlWriter::writeComment(const LString &text)
    {
        LString comment = text;
        // 对输入的字符串是否符合注释规范进行检测
       	// 是否包含注释标识
        if (text.contains("<!--") && text.contains("-->"))
        {
            comment.trim();
            // 注释标识的位置是否正确
            if (comment.indexOf("<!--") == 0 && comment.indexOf("-->") == comment.length() - 3)
            {
                adopt();
                comment.append("\n");
                // 写入
                writeString(comment);
            }
            else
            {
                std::cout << "所输入注释格式不正确" << std::endl;
                return false;
            }
        }
        return true;
    }
    
    // 输入纯注释内容
    void LXmlWriter::writeCommentOrigin(const LString &text)
    {
        if (text.isEmpty())
        {
            return;
        }
        adopt();
        // 构造注释标识然后写入
        LString comment = LString("<!--");
        comment.append(text);
        comment.append("-->");
        comment.append("\n");
        writeString(comment);
    }
    ```

13. 接口逻辑：`writeDTD()`

    - 在`xml`中引入`DTD`文件

    ```xml
    <!DOCTYPE note SYSTEM "Note.dtd">
    ```

    - `DTD`文件内容

    ```dtd
    <!DOCTYPE note
    [
    <!ELEMENT note (to,from,heading,body)>
    <!ELEMENT to (#PCDATA)>
    <!ELEMENT from (#PCDATA)>
    <!ELEMENT heading (#PCDATA)>
    <!ELEMENT body (#PCDATA)>
    ]>
    ```

    - 代码
      - 看起来代码里的实现是让`DTD`文件的内容是内嵌在`xml`文件中
      - 下面的逻辑根本不对啊，判断括号的个数是否匹配？？那万一他们的位置信息不对呢？？？想得出来哦。。

    ```cpp
    bool LXmlWriter::writeDTD(const LString &dtd)
    {
        if (dtd.isEmpty())
            return false;
        LString nowDTD = dtd;
        nowDTD.trim();
        // 先找固定的开头
        if (nowDTD.indexOf("<!DOCTYPE") == 0)
        {
            int left = 0;
            int right = 0;
            int mid = 0;
            int mid2 = 0;
            nowDTD = nowDTD.substr(8, -1);
            // 一个一个匹配 ELEMENT 的格式
            for (int i = 0; i < nowDTD.length(); i++)
            {
                // 由于最开始消耗了一个 < ，因此后续的 > 总会比 < 多一个
                if (nowDTD.at(i) == LChar("<"))
                {
                    i++;
                    if (nowDTD.at(i) == LChar("!"))
                        left++;
                }
                else if (nowDTD.at(i) == LChar(">"))
                    right++;
                // 通过 mid 判断 ( 和 ) 个数一致
                else if (nowDTD.at(i) == LChar("("))
                    mid++;
                else if (nowDTD.at(i) == LChar(")"))
                    mid--;
                // 同样，[ 和 ] 个数一致
                else if (nowDTD.at(i) == LChar("["))
                    mid2++;
                else if (nowDTD.at(i) == LChar("]"))
                    mid2--;
            }
            if (mid == 0 && left == right - 1 && mid2 == 0)
            {
                writeString(dtd);
                writeString("\n");
                return true;
            }
        }
    
        std::cout << "格式有误，写入错误" << std::endl;
        return false;
    }
    ```

14. `writeStartDocument()`接口最后的`return`可以删除

    - 整体逻辑没什么毛病

    ```cpp
    void LXmlWriter::writeStartDocument(const LString &version, const LString &encoding)
    {
        if (!version.isEmpty() && !encoding.isEmpty())
        {
            LString versionadd("<?xml version=\"");
            versionadd.append(version);
            versionadd.append("\" encoding=\"");
            versionadd.append(encoding);
            versionadd.append("\"?>\n");
            m_pStream = versionadd + m_pStream;
        }
        else if (encoding.isEmpty() && !version.isEmpty())
        {
            LString versionadd("<?xml version=\"");
            versionadd.append(version);
            versionadd.append("\"?>\n");
            m_pStream = versionadd + m_pStream;
        }
    
        return;
    }
    ```

15. `writeFileAdd()`和`writeFileRewrite()`功能类似，可以考虑复用

    - 二者功能差不多，只不过一个是`append`，一个是从头`write`

    - 最后的`puts()`那里，代码太冗杂了，拿一个返回值记录即可；并且如果写入失败，也没有做日志输出或者抛出异常等相关处理
    - `writeFileRewrite()`写入以前有`trim()`去除首位空格操作，`writeFileAdd()`却没有

    ```cpp
    bool LXmlWriter::writeFileAdd(LFile &file)
    {
        if (!file.exists())
        {
            std::cout << "文件不存在，新建文件" << std::endl;
        }
        file.open(LFile::OpenMode::Append | LFile::OpenMode::Text);
        // what？？？。。。
        if (file.puts(m_pStream))
        {
            file.close();
            return true;
        }
        file.close();
        return false;
    }
    
    bool LXmlWriter::writeFileRewrite(LFile &file)
    {
        if (!file.exists())
        {
            std::cout << "文件不存在，新建文件" << std::endl;
        }
        file.open(LFile::OpenMode::WriteOnly | LFile::OpenMode::Text);
        if (file.puts(m_pStream))
        {
            // 这里用了前面却不用
            m_pStream.trim();
            file.close();
            return true;
        }
        file.close();
        return false;
    }
    ```

### namespace

1. `namespace`中的所有函数都声明的是静态函数，那为什么不直接声明成静态成员函数，就不用开命名空间了

2. 里面有三个`append()`函数的重载版本，但是在整个文件中没有地方用到，可以删除

   - `mbstate_t`和`mbrtowc()`是标准`C`库的函数，是跨平台的，这个没问题，由于这三个函数没啥用，就不细看了

   ```cpp
   // 根据需要处理转码以将字节字符附加到字符串。
   static void append(std::wstring &strValue, char ch, mbstate_t &state)
   {
       wchar_t dest[4] = {0};
       if (mbrtowc(dest, &ch, 1, &state) > 0)
           strValue += dest;
   }
   
   // 根据需要处理转码以将字节字符附加到字符串。
   static void append(LString &strValue, char ch)
   {
       strValue.append(LChar(ch));
   }
   
   static void append(std::string &strValue, char ch, mbstate_t &state)
   {
   #ifdef UNICODE
       char dest[4] = {0};
       size_t used = 0;
       errno_t err = wcrtomb_s(&used, dest, sizeof dest, ch, &state);
       if (err == 0)
           strValue.append(dest, used);
   #else
       // state;
       strValue += (char)ch;
   #endif
   }
   ```

3. 接口逻辑：`readEntities()`

   - 函数的作用是把`xml`中的实体引用恢复成为其原本的文本的值

   ```cpp
   // 将五个标准 XML 实体扩展为其文本值。
   // &amp; < &gt; ’ “
   // 未识别的实体被保留。
   static void readEntities(const LString &strValue, LString &strResult)
   {
       strResult = LString(""); // 测试是否正确
       bool bEntity = false;
       LString strEntity;
       // 更改为接收所有utf8字符
       // 一个一个字节判断？？？
       for (int i = 0; i < strValue.length(); i++)
       {
           LChar ch = strValue[i];
           // 实体引用开始
           if (ch == LChar("&"))
           {
               bEntity = true;
           }
           // 实体引用结束
           else if (ch == LChar(";"))
           {
        		// 处理实体引用的转换
               if (bEntity)
               {
                   // &
                   if (strEntity.compare("amp") == 0)
                       strResult.append(LChar('&'));
                   // 小于
                   else if (strEntity.compare("lt") == 0)
                       strResult.append(LChar('<'));
                   // 大于
                   else if (strEntity.compare("gt") == 0)
                       strResult.append(LChar('>'));
                   // 双引号
                   else if (strEntity.compare("quot") == 0)
                       strResult.append(LChar('"'));
                   // 单引号
                   else if (strEntity.compare("apos") == 0)
                       strResult.append(LChar('\''));
                   // 都不是，表示不是实体引用
                   else
                   {
                       strResult.append(LChar('&'));
                       strResult.append(strEntity);
                       strResult.append(LChar(';'));
                   }
                   bEntity = false;
               }
           }
           else
           {
               // 如果经过实体引用开始 & ，表示可能是实体引用，加入 strEntity，待后续转化
               if (bEntity)
                   strEntity.append(ch);
               // 加入结果字符串
               else
               {
                   strResult.append(ch);
               }
           }
       }
   }
   
   // 这个是返回字符串是 std::wstring 的版本
   static void readEntities(const LString &strValue, std::wstring &strResult)
   {
       size_t size = strValue.length();
       LString strMulti;
       readEntities(strValue, strMulti);
       strResult.resize(size);
       std::string a = strMulti.toStdString();
       std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
       strResult = converter.from_bytes(a);
   }
   ```

4. 接口逻辑：`insertEntities()`

   - 为什么一来要`reserve()`？`append()`会自动扩容的

   ```cpp
   static void insertEntities(const char *strText, std::string &strEntity)
   {
       strEntity.reserve(64);
       while (*strText != '\0')
       {
           // 将实体文本内容换成实体引用
           char ch = *strText++;
           switch (ch)
           {
           case '\'':
               strEntity += "&apos;";
               break;
           case '&':
               strEntity += "&amp;";
               break;
           case '<':
               strEntity += "&lt;";
               break;
           case '>':
               strEntity += "&gt;";
               break;
           case '"':
               strEntity += "&quot;";
               break;
           default:
               strEntity += ch;
               break;
           }
       }
   }
   ```

