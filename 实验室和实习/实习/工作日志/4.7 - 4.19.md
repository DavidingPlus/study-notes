# 迭代任务

1. `LarkSDK-XML`代码走查（抽象，太抽象了）

# 学习的点

1. `xml`基础教程链接：[https://www.runoob.com/xml/xml-tutorial.html](https://www.runoob.com/xml/xml-tutorial.html)

2. `xml`中的`CDATA`，参考链接：[https://www.w3school.com.cn/xml/xml_cdata.asp](https://www.w3school.com.cn/xml/xml_cdata.asp)

   - 在`xml`文本中，所有文本均会被解析器解析，但`CDATA`区段的文本会被忽略

   - `CDATA`部分由`<![CDATA[`开始，由`]]>`结束

   - 某些文本里面，需要放非法字符例如`<`和`&`，但是又不能使用转移字符，例如传递**代码片段**，就可以使用`CDATA`区段

     ```xml
     <script>
     <![CDATA[
     function matchwo(a,b)
     {
     if (a < b && a < 0) then
       {
       return 1;
       }
     else
       {
       return 0;
       }
     }
     ]]>
     </script>
     ```

   - 补充：`xml`中预定义的实体引用

     ![image-20240407174259533](https://img-blog.csdnimg.cn/direct/3b455de03242431480407094150c798f.png)

3. `xml Token`，参考链接：[https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html](https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html)

   - 对于一个`xml`文件，可以根据起始标签、内容、结束标签、注释、文档开始、文档结束等，将整个文档进行划分，每个小块就是一个`token`，当游标`cursor`移动的过程中，每个位置就会对应一个`tokenType`

     ![image-20240408113635297](https://img-blog.csdnimg.cn/direct/219efb5dea8748dca8e616e1d6a18198.png)

4. `xml DTD`，参考链接：[https://blog.csdn.net/gavin_john/article/details/51532756](https://blog.csdn.net/gavin_john/article/details/51532756)

   - `xml`的标签是用户自定义的，例如我们可以在标签内嵌套标签，例如`<sport><ball>...</ball></sport>`，在这种情况下`sport`中嵌套的标签肯定不可能是随意的，显然不能放`math`，因此需要一个东西来进行约束，这个东西就是`DTD`文件

   - `DTD`语法

     <img src="https://img-blog.csdnimg.cn/direct/b26e7c08f13d45f6a68487091986296a.png" alt="image-20240408140133620" style="zoom:67%;" />

   - 在`xml`中引入`DTD`文件，约束此`xml`

     - 引入中写的`SYSTEM`，表示当前的`DTD`文件是本地
     - 如果写的是`PUBLIC`，则表示引入的`DTD`文件是来自于网络

     ```xml
     <?xml version="1.0" encoding="utf-8"?>
     <!--引入dtd文件，约束这个xml-->
     <!DOCTYPE 班级 SYSTEM "myClass.dtd">
     <班级>
         <学生>
             <名字>周小星</名字>    
             <年龄>23</年龄>
             <介绍>学习刻苦</介绍>
         </学生>   
         <学生>
             <名字>林晓</名字> 
             <年龄>25</年龄>
             <介绍>是一个好学生</介绍>
         </学生>   
     </班级>
     ```

   - 更多细节详见上面链接

# 代码走查问题

1. 整体代码冗杂，三个类的分工不同，建议放在三个文件中，而不是像现在冗杂放在一个文件中

## Parser

由于接口太多了，加上这个代码肯定是要重构的，因此问题的个数不用那么精确了，所以我怕忘了它的逻辑，就把逻辑也放在这里面了。

1. 代码中的英文字符串前后未与中文字符想间隔一个空格，全篇都是，代码就不放了

   - 同时，代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述

2. 代码中的`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类

3. `.cpp`文件中函数定义的开头总是有一行英文注释，在代码中也是

   ```cpp
   // .cpp
   ...
       
   // low-level - match character and advance cursor.
   bool Parser::parseMatch(const LString chPattern)
   {
       bool bOK = peekMatch(chPattern);
       if (bOK)
           m_iCursor += chPattern.length();
       return bOK;
   }
   
   // get next character - but do not advance cursor.
   LChar Parser::peek()
   {
       if (!eof())
           return m_buffer[m_iCursor];
       return LChar("");
   }
   
   ...
   ```

4. 采用结构体`struct`类型，但是确包含`private`成员，虽然合法，但是很抽象

   ```cpp
   struct Parser
   {
       ...
   
   private:
       // 补充预读缓冲区
       void more();
       // 文档读到末尾标识符
       bool m_bEOF;
       // 预读缓冲器
       std::vector<LChar> m_buffer;
       // 当前缓冲区中的字符数
       size_t m_iBuffer;
   };
   ```

5. `m_buffer`读取的缓冲器建议使用`LByteArray`类型

   ```cpp
   // 预读缓冲器
   std::vector<LChar> m_buffer;
   ```

6. 构造函数可以内联

   - `m_pStream`是`LString`类型，但是却用`nullptr`赋值

   ```cpp
   // .cpp
   Parser::Parser() : 
       m_bEOF(false), m_pStream(nullptr), m_iCursor(0), m_iBuffer(0)
   {
   }
   ```

7. `close()`函数做的是清理的工作，命名不规范

   ```cpp
   // close parsing
   void Parser::close()
   {
       m_pStream = LString();
       m_bEOF = true;
       m_iCursor = 0;
       m_iBuffer = 0;
   }
   ```

8. `peekMatch()`函数参数混乱，有`const LString`，有`const LString*`，应该统一用`const LString&`

   ```cpp
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @param iLen 模式长度引用
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern, size_t &iLen);
   
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern);
   
   /**
    * @brief 匹配字符但不推进光标。
    * @param chPattern 需要匹配的字符
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString chPattern);
   ```

9. `peekMatch`的逻辑混乱，两个函数的逻辑实现不一样

   1. 指针版本

      ```cpp
      // low-level - match text but do not advance cursor.
      bool Parser::peekMatch(const LString *strPattern, size_t &iLen)
      {
          size_t i = 0;
          LString patternCopy = *strPattern; // 创建一个新的LString对象拷贝strPattern
          while (true)
          {
              // 如果 i 超出 patternCopy 的大小，并且下面没有返回 false，则说明匹配成功
              if (i >= patternCopy.length())
              {
                  iLen = i;
                  return true;
              }
      
              // 如果 i 超出当前缓冲区的大小，则调用 more() 函数从 m_stream 中拿去更多的字节
              if ((m_iCursor + i) >= m_iBuffer)
                  more();
      
              // 如果扩充完，i 还超出，就返回 false
              if ((m_iCursor + i) >= m_iBuffer)
                  return false;
      
              // 比较传入的字符串和缓冲区中的内容，如果有一个不满足比较条件则返回 false
              // 一个字节一个字节比。。。
              if (patternCopy.at(i) != LChar(m_buffer[m_iCursor + i]))
                  return false;
      
              i++;
          }
      }
      ```

      - 为什么需要第二个参数`iLen`，并且需要传入引用呢？答案是为`parseMatch()`函数服务

      ```cpp
      // low-level - match text and advance cursor.
      bool Parser::parseMatch(const LString *strPattern, size_t &iLen)
      {
          bool bOK = peekMatch(strPattern, iLen);
          if (bOK)
              m_iCursor += iLen; // 这里需要 iLen 移动游标的位置
          return bOK;
      }
      
      // 剩下两个同理
      ...
      ```

   2. 传值版本

      ```cpp
      bool Parser::peekMatch(const LString chPattern)
      {
          bool match = false;
          int n = chPattern.length();
      
          LString now;
          for (int i = 0; i < n; i++)
          {
              // 把缓存中的比较字符串拷贝到 now 中，还是一个一个拷贝，然后进行比较
              // 和前面对比而言，这样写 i 如果超出 m_buffer 边界就会出问题了
              now.append(m_buffer[m_iCursor + i]);
          }
          match = now == chPattern;
      
          return !eof() && m_iCursor < m_iBuffer && match;
      }
      ```

10. `consume()`函数命名不规范，并且逻辑有误

       - 第一，名字为啥叫`consume`，这和前进有啥关系嘛？

       - 返回了`bool`值，但是在整个文件中，并没有找到一处使用了这个返回值，这倒没什么；其次，`m_iCursor`超出边界以后，返回`false`，为什么不把`m_iCursor`重置到原来的位置呢？

    ```cpp
    // consume count characters.
    bool Parser::consume(size_t iCount)
    {
        size_t iRemains = m_iBuffer - m_iCursor;
        if (iRemains < iCount) // 如果剩下的长度小于想前进的长度，则补充缓冲区内容
            more();
        m_iCursor += iCount;
        return m_iCursor <= m_iBuffer;
    }
    ```

11. 接口逻辑：`readText()`和`readCDATAText()`

    ```cpp
    // consume characters up to the delimiter.
    bool Parser::readText(LString &strText, char chDelimiter)
    {
        // 查看是否到达末尾
        while (!eof())
        {
            // 一个一个字符的判断，考虑了跳过 CDATA 段的逻辑
            readCDATAText(strText);
            LChar ch = peek();
            if (ch == LChar(chDelimiter))
            {
                return true;
            }
            // 加入 strText 。。。
            strText.append(LChar(ch));
            consume(1);
        }
        return strText.length() > 0;
    }
    
    bool Parser::readCDATAText(LString &strText)
    {
        // 匹配 CDATA 段起始
        if (peekMatch(LString("<![CDATA[")))
        {
            consume(9); // Consume "<![CDATA["
            // 匹配 CDATA 段结束
            while (!peekMatch(LString("]]>")))
            {
                strText.append(peek());
                consume(1);
            }
            // End of CDATA block
            consume(3); // Consume "]]>"
            return true;
        }
        return false;
    }
    ```

12. 接口逻辑：`skipSpace()`

    ```cpp
    // skips / consumes whitespace.
    int Parser::skipSpace()
    {
        int res = 0;
        // 循环匹配这些字符，然后跳过
        while (peekMatch(LString("\t")) || peekMatch(LString("\r")) || peekMatch(LString("\n")))
        {
            res++;
            consume(1);
        }
        // （原注释）有点奇怪 一起放上面会有问题 会有时match上不该match的东西
        // peekMatch 写的，一言难尽，所以才出现了这种问题
        while (peekMatch(LString(" ")))
        {
            res++;
            consume(1);
        }
        return res;
    }
    ```

13. 接口逻辑：`more()`

    - 这个类里面的冗杂代码和边界条件的代码太多了，不放完整代码了

    - 第一步：将`buffer`中`cursor`以后的部分移动到`buffer`头部

      ```cpp
      // unprocessed data in buffer.
      size_t iCarry = m_iBuffer - m_iCursor;
      // left over data?
      if (iCarry > 0)
      {
          // yes: carry forward unprocessed data.
          LChar *buf = &m_buffer[0];
          memcpy(buf, buf + m_iCursor, iCarry);
      }
      // reset cursor to start of buffer.
      // 不需重置?
      // 对啊，这里注释也写了，为什么不需重置？
      // m_iCursor = 0;
      ```

    - 示意图：

      <img src="https://img-blog.csdnimg.cn/direct/cb14624051954d9a916c0a0e02136c9a.png" alt="image-20240408095910960" style="zoom:75%;" />

    - 第二步：从`m_pStream`中读取内容

      ```cpp
      // 全都进来，what？？？？结合Reader，是一口气把文件的所有内容读进来，如果太大了怎么办
      // 其次，按照这个逻辑，红色部分的内容还没有被读取，直接就从 0 开始赋值？
      for (int i = 0; i < m_pStream.length(); i++)
      {
          ch = m_pStream.at(i);
          m_buffer[i] = ch;
      }
      ```

## XmlReader

1. 代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述

2. 代码中的`std::pair`，`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类

3. `m_attributes`和`m_attributes2`一个使用`STL`的容器，一个使用`SDK`的容器，应统一

   ```cpp
   // 最近的 XML 元素的属性列表。
   std::list<std::pair<LString, LString>> m_attributes;
   LList<LPair<LString, LString>> m_attributes2;
   ```

4. 所有的构造函数通过初始化序列初始化成员变量，但是在函数体中又重复做了一次

   ```cpp
   // 默认构造
   LXmlReader::LXmlReader() : m_bStart(false), m_iSkipped(0)
   {
       // 这里又重复赋值一次
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open("");
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   // 其他的同理
   ...
   ```

5. 构造函数的使用参数`const LString&`，`const LByteArray&`，`const char*`时，可以代码复用，但是目前的实现冗杂

   ```cpp
   LXmlReader::LXmlReader(const LString &inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open(inputStream);
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   LXmlReader::LXmlReader(const LByteArray &inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       bool open = m_parser.open(inputStream.toString());
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   
   LXmlReader::LXmlReader(const char *inputStream) : m_bStart(false), m_iSkipped(0)
   {
       m_bStart = false;
       m_iSkipped = 0;
       // LEntry enty;
       // m_stack.push_back(enty);
       LString now(inputStream);
       bool open = m_parser.open(now);
       if (!open)
       {
           std::cout << "格式不正确，构造失败" << std::endl;
       }
   }
   ```

6. `LXmlReader`通过传入`LFile&`参数构造读取器的时候，将整个文件的所有内容一次性读进来，放入`m_parser`中

   - 按照`expat`库的思路，应该是通过流式进行处理，例如读取一行处理一行，这样能够避免在内存中开辟过大的内存，这才是`stream`，而不是`tree`

   ```cpp
   LXmlReader::LXmlReader(LFile &inputStream) : m_bStart(false), m_iSkipped(0)
   {
   	...
           
       LString file;
       while (!inputStream.end())
       {
           file.append(inputStream.readLine().toString());
       }
   
       bool open = m_parser.open(file);
       if (!open)
       {
           std::cout << "构造失败" << std::endl;
       }
   	...
   }
   ```

7. `addData()`接口同样可以复用，同构造函数

   - 并且函数可以内联

   ```cpp
   void LXmlReader::addData(const LString &data)
   {
       m_parser.m_pStream.append(data);
   }
   
   void LXmlReader::addData(const LByteArray &data)
   {
       m_parser.m_pStream.append(data.toString());
   }
   
   void LXmlReader::addData(const char *data)
   {
       m_parser.m_pStream.append(data);
   }
   ```

8. 接口逻辑：`parseToken()`

   - 局部变量`upIndex`没有什么作用

   ```cpp
   // parse a token
   bool LXmlReader::parseToken(LString &strToken)
   {
       LChar ch = m_parser.peek();
       LString nowString;
       int upIndex = 0;
       //?? 是否需要ch>=0
       // 一个字符一个字符判断，目的是卡好一个 token 的范围（至于功能上能不能卡好我也无从验证）
       while (ch != LChar('=') && ch != LChar('/') && ch != LChar('>') && ch != LChar('"') && ch != LChar(' ') && ch != LChar('\''))
       {
           nowString.append(ch);
           m_parser.consume(1);
           upIndex++;
           ch = m_parser.peek();
       }
       strToken = nowString;
       return strToken.length() > 0;
   }
   ```

   - 为什么传递参数`strToken`，还是引用？最后返回的还是一个`bool`值；单从本函数的逻辑上来看，完全可以将`nowString`返回，如果为空就代表失败

     - 查看了`parseToken()`调用的地方，就明白了，在源文件中有两处
     - 无非就想把解析出的结果记录在`element`或者`pair`中，那直接用返回值记录啊

     ```cpp
     // returns true start of an element is successfully consumed.
     // if true, the element's attributes are available below through getAttribute.
     bool LXmlReader::readStartElement()
     {
         LEntry element;
         if (isStartElement() && parseToken(element.m_element))
         {
            ...
         }
         
         ...
     }
     
     // parse attribute=quoted-value sequence.
     bool LXmlReader::parseAttribute()
     {
         std::pair<LString, LString> pair;
         bool bOK = skipspace(true) && parseToken(pair.first);
         
         ...
     }
     ```

9. 接口逻辑：`skipspace()`

   - 接口命名不规范，应使用小驼峰`skipSpace`
   - 参数`bInside`：判断是在元素声明内还是外部
     - 在内部，跳过空格、注释等非正文内容，直到遇到正文内容或其他标记为止
     - 在外部，除了上面的内容，还会处理一些文档声明，例如`XML`版本，编码信息，`DTD`声明等
   - 这里面的所有匹配都是硬匹配的，这个函数就是一个非常经典的例子，单从匹配的角度来讲，可以考虑正则表达式而不是硬匹配
   - 在内部处理注释的时候，应匹配注释开始`<!--`和注释结束`-->`而不是`--`
   - `TODO`：`bInside`为`false`的时候处理注释的逻辑目前看不懂

   ```cpp
   // skips / consumes whitespace.
   // bInside - true if inside an element declaration eg. between '<' and '>'.
   bool LXmlReader::skipspace(bool bInside)
   {
       if (bInside)
       {
           while (true)
           {
               // 1. 匹配空格
               m_parser.skipSpace();
               // 2. 匹配注释
               if (m_parser.peekMatch("--"))
               {
                   m_parser.consume(2);
                   // 在注释内部，跳过注释内容
                   while (!m_parser.eof() && !m_parser.peekMatch("--"))
                       m_parser.consume(1);
                   // 匹配到注释结尾
                   if (m_parser.peekMatch("--"))
                       m_parser.consume(2);
               }
               else
                   break;
           }
       }
       else
       {
           while (true)
           {
               // 1. 匹配空格
               m_parser.skipSpace();
               // 2. 匹配注释
               // 基本逻辑和上面是一样的，但是这里多了很多成员变量的修改
               // TODO 下面关于 m_Comment 和 m_stack 目前看不懂
               if (m_parser.peekMatch("<!--"))
               {
                   bool flag1 = (m_stack.size() != 0);
                   m_parser.consume(4);
                   if (flag1)
                       m_stack.back().m_iComment = LString("");
                   m_Comment = LString("");
                   while (!m_parser.eof() && !m_parser.peekMatch("-->"))
                   {
                       if (flag1)
                           m_stack.back().m_iComment.append(m_parser.peek());
                       m_Comment.append(m_parser.peek());
                       m_parser.consume(1);
                   }
                   if (m_parser.peekMatch("-->"))
                       m_parser.consume(3);
                   // m_stack.back().m_iComment.append(LString(" "));
                   m_parser.skipSpace();
                   if (flag1)
                       m_stack.back().m_commentIndex = LString::fromInt(characterOffset());
               }
               // 3. 匹配版本号和编码信息
               // <?xml version="1.0" encoding="utf-8"?> 匹配固定模式，逻辑固定
               else if (m_parser.peekMatch("<?"))
               {
                   m_parser.consume(2);
                   while (!m_parser.eof() && !m_parser.peekMatch("?>"))
                   {
                       // 获取版本信息
                       if (m_parser.peekMatch("version"))
                       {
                           ...
                       }
                       // 获取编码信息
                       else if (m_parser.peekMatch("encoding"))
                       {
                           ...
                       }
                   }
                   if (m_parser.peekMatch("?>"))
                       m_parser.consume(2);
               }
               // 3. 匹配 DTD 声明
               // <!DOCTYPE 班级 SYSTEM "myClass.dtd"> 匹配固定模式，逻辑固定
               else if (m_parser.peekMatch("<!DOCTYPE"))
               {
                  ...
               }
               else
                   break;
           }
       }
       return true;
   }
   ```

10. 接口逻辑：`parseAttribute()`

    - 关于`m_attributes`和`m_attributes2`，上面提到过，一个用的是`STL`，一个用的是`SDK`，但是在这里两个东西存储的数据是一模一样的，因此有理由怀疑这两个东西其实是一个东西，可以删除一个

    ```cpp
    // parse attribute=quoted-value sequence.
    bool LXmlReader::parseAttribute()
    {
        std::pair<LString, LString> pair;
        // 跳过空格并且解析 key
        bool bOK = skipspace(true) && parseToken(pair.first);
        if (bOK)
        {
            // 解析 = 号
            bool FLag1 = skipspace(true) && m_parser.parseMatch(LString("=")) && skipspace(true);
            // 由于属性可能被单引号或者双引号扩充起来，因此两个都进行判断
            // 由于 parseMatch 只有成功才会修改游标 curSor，因此这里的逻辑是没问题的
            bool Flag2 = m_parser.parseMatch(LString("\'")) && m_parser.readText(pair.second, '\'') && m_parser.parseMatch(LString("\'"));
            bool Flag3 = m_parser.parseMatch(LString("\"")) && m_parser.readText(pair.second, '"') && m_parser.parseMatch(LString("\""));
            bOK = FLag1 && (Flag2 || Flag3);
            if (bOK)
            {
                m_attributes.push_back(pair);
                LPair<LString, LString> pair2;
                pair2.key() = pair.first;
                pair2.value() = pair.second;
                m_attributes2.append(pair2);
            }
        }
        return bOK;
    }
    ```

11. 接口逻辑：`readStartElement()`

    - 两个重载版本，第一个的参数应该用`const LString&`
    - 当前元素是否具有子元素`m_children`，代码中是直接判断是能否解析到`>`，从这个函数来看，这个逻辑是不合理的，应该判断这个起始标签的下一个位置是不是子元素的起始标签，这样才是合理的

    ```cpp
    // returns true if start of named element is successfully consumed.
    // if true, the element's attributes are available below through getAttribute.
    bool LXmlReader::readStartElement(const LString *strElement)
    {
        LEntry element;
        size_t iLen = 0;
        // 如果传入字符串为空，则失败
        if (strElement == nullptr || strElement->isEmpty())
            return false;
        // 判断当前是否为起始标签，并且是否能够成功解析
        if (isStartElement() && m_parser.parseMatch(strElement, iLen))
        {
            // element.Element.assign(strElement, iLen);
            //??
            LString a = *strElement;
            // 修改元素实体的内容
            element.m_element = a.substr(0, iLen);
            // 修改属性
            m_attributes.clear();
            m_attributes2.clear();
            while (parseAttribute())
                ;
            // 记录当前元素是否具有子元素，这个逻辑不对吧。。
            element.m_children = m_parser.parseMatch(LString(">"));
            // 加入嵌套的栈
            m_stack.push_back(element);
            m_bStart = false;
            return true;
        }
        return false;
    }
    
    // returns true start of an element is successfully consumed.
    // if true, the element's attributes are available below through getAttribute.
    bool LXmlReader::readStartElement()
    {
        // 思路和前面基本一致
        LEntry element;
        // 只是这里改为直接解析 token 去了
        if (isStartElement() && parseToken(element.m_element))
        {
            m_attributes.clear();
            m_attributes2.clear();
            while (parseAttribute())
                ;
            element.m_children = m_parser.parseMatch(LString(">"));
            m_stack.push_back(element);
            m_bStart = false;
            return true;
        }
        return false;
    }
    ```

## XmlWriter

