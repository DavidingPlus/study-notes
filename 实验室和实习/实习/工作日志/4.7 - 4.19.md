# 迭代任务

1. `LarkSDK-XML`代码走查（抽象，太抽象了）

# 代码走查问题

## Parser

由于接口太多了，加上这个代码肯定是要重构的，因此问题的个数不用那么精确了，所以我怕忘了它的逻辑，就把逻辑也放在这里面了。

1. 代码中的英文字符串前后未与中文字符想间隔一个空格，全篇都是，代码就不放了

2. 代码中的`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类

3. `.cpp`文件中函数定义的开头总是有一行英文注释，在代码中也是

   ```cpp
   // .cpp
   ...
       
   // low-level - match character and advance cursor.
   bool Parser::parseMatch(const LString chPattern)
   {
       bool bOK = peekMatch(chPattern);
       if (bOK)
           m_iCursor += chPattern.length();
       return bOK;
   }
   
   // get next character - but do not advance cursor.
   LChar Parser::peek()
   {
       if (!eof())
           return m_buffer[m_iCursor];
       return LChar("");
   }
   
   ...
   ```

4. 采用结构体`struct`类型，但是确包含`private`成员，虽然合法，但是很抽象

   ```cpp
   struct Parser
   {
       ...
   
   private:
       // 补充预读缓冲区
       void more();
       // 文档读到末尾标识符
       bool m_bEOF;
       // 预读缓冲器
       std::vector<LChar> m_buffer;
       // 当前缓冲区中的字符数
       size_t m_iBuffer;
   };
   ```

5. `m_buffer`读取的缓冲器建议使用`LByteArray`类型

   ```cpp
   // 预读缓冲器
   std::vector<LChar> m_buffer;
   ```

6. 构造函数可以内联

   - `m_pStream`是`LString`类型，但是却用`nullptr`赋值

   ```cpp
   // .cpp
   Parser::Parser() : 
       m_bEOF(false), m_pStream(nullptr), m_iCursor(0), m_iBuffer(0)
   {
   }
   ```

7. `peekMatch()`函数参数混乱，有`const LString`，有`const LString*`，应该统一用`const LString&`

   ```cpp
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @param iLen 模式长度引用
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern, size_t &iLen);
   
   /**
    * @brief 匹配文本但不前进光标。
    * @param strPattern 需要匹配的文本
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString *strPattern);
   
   /**
    * @brief 匹配字符但不推进光标。
    * @param chPattern 需要匹配的字符
    * @return true则匹配成功；否则失败
    */
   bool peekMatch(const LString chPattern);
   ```

8. `peekMatch`的逻辑混乱，两个函数的逻辑实现不一样

   1. 指针版本

      ```cpp
      // low-level - match text but do not advance cursor.
      bool Parser::peekMatch(const LString *strPattern, size_t &iLen)
      {
          size_t i = 0;
          LString patternCopy = *strPattern; // 创建一个新的LString对象拷贝strPattern
          while (true)
          {
              // 如果 i 超出 patternCopy 的大小，并且下面没有返回 false，则说明匹配成功
              if (i >= patternCopy.length())
              {
                  iLen = i;
                  return true;
              }
      
              // 如果 i 超出当前缓冲区的大小，则调用 more() 函数从 m_stream 中拿去更多的字节
              if ((m_iCursor + i) >= m_iBuffer)
                  more();
      
              // 如果扩充完，i 还超出，就返回 false
              if ((m_iCursor + i) >= m_iBuffer)
                  return false;
      
              // 比较传入的字符串和缓冲区中的内容，如果有一个不满足比较条件则返回 false
              // 一个字节一个字节比。。。
              if (patternCopy.at(i) != LChar(m_buffer[m_iCursor + i]))
                  return false;
      
              i++;
          }
      }
      ```

      - 为什么需要第二个参数`iLen`，并且需要传入引用呢？答案是为`parseMatch()`函数服务

      ```cpp
      // low-level - match text and advance cursor.
      bool Parser::parseMatch(const LString *strPattern, size_t &iLen)
      {
          bool bOK = peekMatch(strPattern, iLen);
          if (bOK)
              m_iCursor += iLen; // 这里需要 iLen 移动游标的位置
          return bOK;
      }
      
      // 剩下两个同理
      ...
      ```

   2. 传值版本

      ```cpp
      bool Parser::peekMatch(const LString chPattern)
      {
          bool match = false;
          int n = chPattern.length();
      
          LString now;
          for (int i = 0; i < n; i++)
          {
              // 把缓存中的比较字符串拷贝到 now 中，还是一个一个拷贝，然后进行比较
              // 和前面对比而言，这样写 i 如果超出 m_buffer 边界就会出问题了
              now.append(m_buffer[m_iCursor + i]);
          }
          match = now == chPattern;
      
          return !eof() && m_iCursor < m_iBuffer && match;
      }
      ```

9. `consume()`函数命名不规范，并且逻辑有误

   - 第一，名字为啥叫`consume`，这和前进有啥关系嘛？
   - 返回了`bool`值，但是在整个文件中，并没有找到一处使用了这个返回值，这倒没什么；其次，`m_iCursor`超出边界以后，返回`false`，为什么不把`m_iCursor`重置到原来的位置呢？

   ```cpp
   // consume count characters.
   bool Parser::consume(size_t iCount)
   {
       size_t iRemains = m_iBuffer - m_iCursor;
       if (iRemains < iCount) // 如果剩下的长度小于想前进的长度，则补充缓冲区内容
           more();
       m_iCursor += iCount;
       return m_iCursor <= m_iBuffer;
   }
   ```

10. 接口逻辑：`readText()`和`readCDATAText()`

    ```cpp
    // consume characters up to the delimiter.
    bool Parser::readText(LString &strText, char chDelimiter)
    {
        // 查看是否到达末尾
        while (!eof())
        {
            // 一个一个字符的判断，考虑了跳过 CDATA 段的逻辑
            readCDATAText(strText);
            LChar ch = peek();
            if (ch == LChar(chDelimiter))
            {
                return true;
            }
            // 加入 strText 。。。
            strText.append(LChar(ch));
            consume(1);
        }
        return strText.length() > 0;
    }
    
    bool Parser::readCDATAText(LString &strText)
    {
        // 匹配 CDATA 段起始
        if (peekMatch(LString("<![CDATA[")))
        {
            consume(9); // Consume "<![CDATA["
            // 匹配 CDATA 段结束
            while (!peekMatch(LString("]]>")))
            {
                strText.append(peek());
                consume(1);
            }
            // End of CDATA block
            consume(3); // Consume "]]>"
            return true;
        }
        return false;
    }
    ```

11. 接口逻辑：`skipSpace()`

    ```cpp
    // skips / consumes whitespace.
    int Parser::skipSpace()
    {
        int res = 0;
        // 循环匹配这些字符，然后跳过
        while (peekMatch(LString("\t")) || peekMatch(LString("\r")) || peekMatch(LString("\n")))
        {
            res++;
            consume(1);
        }
        // （原注释）有点奇怪 一起放上面会有问题 会有时match上不该match的东西
        // peekMatch 写的，一言难尽，所以才出现了这种问题
        while (peekMatch(LString(" ")))
        {
            res++;
            consume(1);
        }
        return res;
    }
    ```

## XmlReader

1. `LXmlReader`通过传入`LFile`参数构造读取器的时候，将整个文件的所有内容一次性读进来，放入`m_parser`中

   - 按照`expat`库的思路，应该是通过流式进行处理，例如读取一行处理一行，这样能够避免在内存中开辟过大的内存，这才是`stream`，而不是`tree`

   ```cpp
   LXmlReader::LXmlReader(LFile &inputStream) : m_bStart(false), m_iSkipped(0)
   {
   	...
           
       LString file;
       while (!inputStream.end())
       {
           file.append(inputStream.readLine().toString());
       }
   
       bool open = m_parser.open(file);
       if (!open)
       {
           std::cout << "构造失败" << std::endl;
       }
   	...
   }
   ```

## XmlWriter

# 学习的点

1. `xml`基础教程链接：[https://www.runoob.com/xml/xml-tutorial.html](https://www.runoob.com/xml/xml-tutorial.html)

2. `xml`中的`CDATA`，参考链接：[https://www.w3school.com.cn/xml/xml_cdata.asp](https://www.w3school.com.cn/xml/xml_cdata.asp)

   - 在`xml`文本中，所有文本均会被解析器解析，但`CDATA`区段的文本会被忽略

   - `CDATA`部分由`<![CDATA[`开始，由`]]>`结束

   - 某些文本里面，需要放非法字符例如`<`和`&`，但是又不能使用转移字符，例如传递**代码片段**，就可以使用`CDATA`区段

     ```xml
     <script>
     <![CDATA[
     function matchwo(a,b)
     {
     if (a < b && a < 0) then
       {
       return 1;
       }
     else
       {
       return 0;
       }
     }
     ]]>
     </script>
     ```

   - 补充：`xml`中预定义的实体引用

     ![image-20240407174259533](https://img-blog.csdnimg.cn/direct/3b455de03242431480407094150c798f.png)

