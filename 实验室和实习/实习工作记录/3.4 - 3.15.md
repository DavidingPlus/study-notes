# 迭代任务

1. 走查画笔`LPen`，画刷`LBrush`、`LLinearGradient`，菜单`LMenu`、`LMenuItem`部分代码

# 代码走查问题

## 画笔

### LPen

1. `JointType`线段交点样式，目前是只有一种方式，后续还有更多方式引入吗？

   - 如果有引入，那么构造函数对应也需要进行改造，构造函数见第`2`点

   ~~~cpp
   /**
    * @enum JointType
    * @brief 线段交点样式定义，表示线段相交时，不同的连接方式。
    */
   enum JointType
   {
       FlatJoint = 0       ///< 直接连接，没有拐点修饰
   };
   ~~~

2. 构造函数注释少写`@param color`

   - `m_width`不能直接赋值，因为有可能小于 `1`，需要调用`setColor()`

   ```cpp
   /**
    * @brief 构造函数，设置画笔宽度。
    * @param width 画笔宽度
    */
   explicit LPen(int width = 1, const LColor &color = LColor()) : m_width(width), m_color(color) {}
   ```

3. 拷贝构造函数、`width()`接口的`@brief`没有句号

   ```cpp
   /**
   * @brief 拷贝构造函数
   * @param other 待拷贝对象
   */
   LPen(const LPen &other) : m_width(other.width()), m_jointType(other.jointType()), m_color(other.color()) {}
   
   ...
   
   /**
   * @brief 返回画笔宽度
   * @return 画笔宽度
   */
   int width() const { return m_width; }
   ```

4. `setColor()`接口参数传常量引用更好一点

   ```cpp
   /**
    * @brief 设置画笔颜色。
    * @param color 画笔颜色
    */
   void setColor(LColor color) { m_color = color; }
   ```

5. `m_width`注释错误

   ~~~cpp
   /**
    * @brief 画笔连接样式。
    */
   int m_width = 0;
   ~~~

## 画刷

### LBrush

1. 拷贝构造函数可以内联

   ```cpp
   LBrush::LBrush(const LBrush &other) :
       m_brushType(other.type()),
       m_color(other.color())
   {
       m_pGradient = new LLinearGradient(*(other.gradient()));
   }
   ```

2. `setBrushType`的`@param`的单词与参数不对应

   ```cpp
   /**
    * @brief 设置笔刷样式。
    * @param brushTypes 笔刷样式
    */
   void setBrushType(BrushType brushType);
   ```

3. `setGradient`的`@param`与参数不对应

   - 单词不对应，描述也不对应

   ```cpp
   /**
    * @brief 设置渐变色属性。
    * @param pGradient 渐变色类指针
    */
   void setGradient(const LLinearGradient &gradient);
   ```

4. 代码中`LLinearGradient`结构存放的是指针，内存放在堆区，个人认为完全没有必要

   - `LLinearGradient`的成员变量如下，存这些东西哪里需要放在堆区？
   - 这里更改之后，源文件中关于指针`new`和`delete`的东西都需要进行修改

   ~~~cpp
   class LLinearGradient
   {
   	...
           
   private:
       
       ...
           
   	/**
        * @brief 标识渐变起点坐标。
       */
       LPoint m_start;   
       /**
        * @brief 标识渐变终点坐标。
       */                   
       LPoint m_finalStop;
       /**
        * @brief 标识渐变铺展效果，默认为PadMode。
       */                   
       GradientMode m_mode = PadMode;
       /**
        * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。
       */   
       LVector<LPair<double, LColor>> m_stops;
   };
   ~~~

   - 同时构造函数的逻辑也需要进行修正
     - `BrushType`根据不同的类型用到不同的成员变量，`NoBrush`啥都用不到，`SolidBrush`用到`m_color`，`LinearGradientBrush`用到`m_pGradient`
     - 现在的构造函数逻辑有一些紊乱，用户没办法在构造函数中直接给出线性渐变相关的参数，这是不合适的，我认为修改的版本应给出三个，一个是默认的构造函数，对应`NoBrush`；第二个是针对`LColor`的构造函数，对应`SolidBrush`；第三个是针对`LLinearGradient`的构造函数，对应`LinearGradientBrush`

   ```cpp
   // 原有的
   
   // .h
   /**
    * @brief 构造函数。
    * @param color 笔刷颜色
    * @param brushType 笔刷样式
    */
   explicit LBrush(const LColor &color = LColor(), BrushType brushType = LBrush::SolidBrush) : m_brushType(brushType), m_color(color) {}
   
   // .cpp
   LBrush::LBrush(const LBrush &other) :
       m_brushType(other.type()),
       m_color(other.color())
   {
       LLinearGradient *pGradient = other.gradient();
       if (pGradient)
       {
           m_pGradient = new LLinearGradient(*pGradient);
       }
   }
   ```

5. `setBrushType()`接口逻辑混乱，设计不合理

   - 这个接口设置的初衷就是用户可以调用设置`brushType`，但是第一行判断如果是渐变，则无法设置，这就很扯淡了

   ```cpp
   void LBrush::setBrushType(BrushType brushType)
   {
       if (brushType == LBrush::LinearGradientBrush)
       {
           throw LException("无法通过setBrushType设置渐变色，请使用setGradient"); 
       }
       m_brushType = brushType;
       if (m_pGradient)
       {
           delete m_pGradient;
           m_pGradient = nullptr;
       }
   }
   ```

   - 按理来说，`brushType`是能用户任意设置的，需要做判断的是不同`brushType`的各自接口，比如`setColor()`，`setGradient()`，`color()`，`gradient()`

   ```cpp
   // .h
   /**
   * @brief 返回笔刷颜色.
   * @return 笔刷颜色
   */
   LColor color() const { return m_color; }
   
   /**
   * @brief 获得该笔刷的渐变色属性。
   * @return 渐变色属性
   */
   LLinearGradient* gradient() const { return m_pGradient; }
   
   
   /**
   * @brief 设置笔刷颜色。
   * @param color 笔刷颜色
   */
   void setColor(LColor color) { this->m_color = color; }
   
   // .cpp
   void LBrush::setGradient(const LLinearGradient &gradient)
   {
       m_brushType = LBrush::LinearGradientBrush;
       if (m_pGradient)
       {
           delete m_pGradient;
       }
       m_pGradient = new LLinearGradient(gradient);
   }
   ```

### LLinearGradient

1. 头文件`<cmath>`的引入错误

   ```cpp
   #include "lpoint.h"
   #include "lcolor.h"
   #include "lvector.h"
   #include "lpair.h"
   #include "cmath"
   ```

2. `enum`的格式不正确，少了`@enum`，`{`应该提行

   ```cpp
   /**
    * @brief 铺展效果枚举。
   */
   enum GradientMode {
       PadMode,             ///<默认铺展效果，没有被渐变覆盖的区域填充单一的起始颜色或终止颜色
       RepeatMode           ///<渐变在起点与终点的渐变区域外重复
   };
   ```

3. 代码中有很多应该有空行，但没有空行的格式问题

   ```cpp
   #include "lpoint.h"
   #include "lcolor.h"
   #include "lvector.h"
   #include "lpair.h"
   #include "cmath"
   /**
    * @class LLinearGradient
    * @brief 渐变色填充类,与LBrush结合使用，以指定线形渐变笔刷。
    * @details 默认初始起点颜色为黑色，终点颜色为白色。
    */
   class LLinearGradient
   {
   
   public:
       /**
        * @brief 铺展效果枚举。
       */
       enum GradientMode {
           PadMode,             ///<默认铺展效果，没有被渐变覆盖的区域填充单一的起始颜色或终止颜色
           RepeatMode           ///<渐变在起点与终点的渐变区域外重复
       };
       /**
        * @brief 默认构造函数。
        */
       LLinearGradient();
   
       ...
       
       /**
        * @brief 标识渐变起点坐标。
       */
       LPoint m_start;   
       /**
        * @brief 标识渐变终点坐标。
       */                   
       LPoint m_finalStop;
       /**
        * @brief 标识渐变铺展效果，默认为PadMode。
       */                   
       GradientMode m_mode = PadMode;
       /**
        * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。
       */   
       LVector<LPair<double, LColor>> m_stops;
   };
   ```

4. 代码中有很多内联函数，格式不正确

   ```cpp
   /**
    * @brief 设置渐变起点位置。
    * @param start 渐变起点坐标
    */
   void setStart(const LPoint &start)
   {
       m_start = start;
   }
   
   ...
   
   /**
    * @brief 设置渐变终点位置。
    * @param finalStop 渐变终点坐标
    */
   void setFinalStop(const LPoint &finalStop)
   {
       m_finalStop = finalStop;
   }
   
   ...
   
   /**
    * @brief 设置铺展效果。
    * @param mode 铺展效果
   */
   void setMode(GradientMode mode)
   {
       m_mode = mode;
   }
   
   ...
   
   /**
    * @brief 获取渐变起点。
    */
   LPoint start() const
   {
       return LPoint(m_start);
   }
   
   /**
    * @brief 获取渐变终点。
    */
   LPoint finalStop() const
   {
       return LPoint(m_finalStop);
   }
   
   /**
    * @brief 获取铺展效果。
   */
   GradientMode mode() const 
   { 
       return m_mode; 
   }
   
   /**
    * @brief 获取渐变颜色数组。
   */
   LVector<LPair<double, LColor>> stops() const 
   { 
       return m_stops; 
   }
   ```

5. 头文件中很多函数不能内联

   ```cpp
   /**
    * @brief 设置渐变起点位置。
    * @param x 渐变起点横坐标
    * @param y 渐变起点纵坐标
    */
   void setStart(int x, int y)
   {
       m_start.setX(x);
       m_start.setY(y);
   }
   
   ...
       
   /**
    * @brief 设置渐变终点位置。
    * @param x 渐变终点横坐标
    * @param y 渐变终点纵坐标
    */
   void setFinalStop(int x, int y)
   {
       m_finalStop.setX(x);
       m_finalStop.setY(y);
   }
   
   ...
   
   /**
    * @brief 设置渐变颜色数组。
    * @param stops 渐变颜色数组
   */
   void setStops(const LVector<LPair<double, LColor>> &stops)
   {
       m_stops = stops;
       if (m_stops.first().key() != 0)
       {
           m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));
       }
       if (m_stops.last().key() != 1)
       {
           m_stops.append(LPair<double, LColor>(1, LColor(255,255,255)));
       }
   }
   ```

6. 源文件中有的函数可以内联

   ```cpp
   LLinearGradient::LLinearGradient(int x1, int y1, int x2, int y2)
       : LLinearGradient(LPoint(x1, y1), LPoint(x2, y2))
   {
   }
   
   LLinearGradient::~LLinearGradient()
   {
   }
   ```

7. 代码中很多`LVector`的插入可以调用`prepend()`或者`append()`

   ```cpp
   // .h
   void setStops(const LVector<LPair<double, LColor>> &stops)
   {
       m_stops = stops;
       if (m_stops.first().key() != 0)
       {
           m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));
       }
       if (m_stops.last().key() != 1)
       {
           m_stops.append(LPair<double, LColor>(1, LColor(255,255,255)));
       }
   }
   
   ...
   
   // .cpp
   LLinearGradient::LLinearGradient()
   {
   	...
       
       m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));
       m_stops.insert(1, LPair<double, LColor>(1, LColor(255,255,255)));
   }
   
   LLinearGradient::LLinearGradient(const LPoint &start, const LPoint &finalStop)
   {
   	...
       
       m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));
       m_stops.insert(1, LPair<double, LColor>(1, LColor(255,255,255)));
   }
   ```

8. `setColor()`接口代码冗杂，这下面的部分一行就能搞定

   - 接口作用：根据输入的渐变比例`pos`值插入到数组中；我们需要保证标识渐变点数组是按照渐变比例`pos`递增的，因此可以采用二分的思路，这里查询的是不小于`pos`的第一个元素下标
   - 上面的二分思路，另一处代码中也用到了，查询的位置相同，可以封装出来进行复用
   - 注释的`{`也有问题

   ```cpp
   void LLinearGradient::setColor(double pos, const LColor &color) {
   	... 
           
       // 如果已经存在对应的pos值，则覆盖颜色值
       if (index < m_stops.size() && m_stops[index].key() == pos)
       {
           m_stops[index].value() = color;
       }
       else
       {
           m_stops.insert(index, LPair<double, LColor>(pos, color));
       }
   }
   ```

9. `getColor()`接口，分了三种情况，经过数学推导，一个公式就能搞定

   - 推导过程

     <img src="https://img-blog.csdnimg.cn/direct/6744797cf27e410cb9f6d45a6d5d622d.png" alt="96267918b6de05e058c90fee24804e4" style="zoom:30%;" />

   - 接口作用：根据输入点的坐标得出该点的颜色，本函数只负责将坐标转化为渐变比例`pos`（原始值），`pos`的处理和计算颜色的具体逻辑交给`getColorByPadMode()`和`getColorByRepeatMode()`

   - 计算出`pos`之后，分铺展情况调用不同接口一行也能搞定

   ```cpp
   LColor LLinearGradient::getColor(const LPoint &point) const
   {
       if (m_stops.size() < 2)
       {
           throw LException("尚未完整初始化颜色：至少提供两种颜色");
       }
       // 垂直渐变
       if (m_start.x() == m_finalStop.x() && m_start.y() != m_finalStop.y())
       {
           // 竖向渐变
           double pos = (point.y() - m_start.y()) / static_cast<double>(m_finalStop.y() - m_start.y());
           if (m_mode == PadMode)  // PadMode铺展
           {
               return getColorByPadMode(pos);
           }
           else  // RepeatMode铺展
           {
               return getColorByRepeatMode(pos);
           }
       }
       if (m_start.y() == m_finalStop.y() && m_start.x() != m_finalStop.x())
       {
           // 横向渐变
           double pos = (point.x() - m_start.x()) / static_cast<double>(m_finalStop.x() - m_start.x());
           if (m_mode == PadMode)  // PadMode铺展
           {
               return getColorByPadMode(pos);
           }
           else  // RepeatMode铺展
           {   
               return getColorByRepeatMode(pos);
           }
       }
       // 非垂直渐变
       // c为起点与终点之间的距离
       double c = sqrt(std::pow((m_start.x() - m_finalStop.x()),2) + std::pow((m_start.y() - m_finalStop.y()),2));
       // 通过坐标旋转将非垂直渐变转变为垂直渐变
       double revolve_x = ((point.x() - m_start.x()) * (m_finalStop.x() - m_start.x()) / c) - 
                          ((point.y() - m_start.y()) * (-(m_finalStop.y() - m_start.y())) / c);
       double pos = revolve_x / c;
       if (m_mode == PadMode)  // PadMode铺展
       {
           return getColorByPadMode(pos);
       }
       else  // RepeatMode铺展
       {
           return getColorByRepeatMode(pos);
       }
   }
   ```

10. `getColorByT()`接口代码冗杂，同上

       - 接口作用：这个函数才是根据真正输入的渐变比例`pos`值，找到其在升序数组中的位置，有人为设置则直接返回；没有则根据左右计算，具体逻辑在`computeColorByT()`

    ```cpp
    LColor LLinearGradient::getColorByT(double t) const
    {
        ...
        
        // 如果渐变比例t刚好在m_stops中有对应值，则返回对应的颜色参数
        if (m_stops[right].key() == t)
        {
            return m_stops[right].value();
        }
        // 计算新的渐变比例值
        double target = (t - m_stops[left].key()) / (m_stops[right].key() - m_stops[left].key());
        return computeColorByT(m_stops[left].value(), m_stops[right].value(), target);
    }
    ```

11. `getColorByPadMode()`接口代码冗杂，同上

    - 接口作用：这个接口和下面那个的区别在于，一个是`PadMode`，一个是`RepeatMode`，前者在超出区域使用边界值，后者在把超出区域视作另一个区域，进行重复

    ```cpp
    LColor LLinearGradient::getColorByPadMode(double t) const
    {
        if (t <= 1 && t >= 0)
        {
            return getColorByT(t);
        }
        else if (t < 0)
        {
            return LColor(m_stops.first().value());
        }
        else
        {
            return LColor(m_stops.last().value());
        }
    }
    ```

12. `getColorByRepeatMode()`接口代码冗杂，同上

    ```cpp
    LColor LLinearGradient::getColorByRepeatMode(double t) const
    {
        double pos;
        if (t < 0)
        {
            pos = 1 - fabs(fmod(t, 1));
        }
        else
        {
            pos = fabs(fmod(t, 1));
        }
        return getColorByT(pos);
    }
    ```

13. `computeColorByT()`接口代码冗杂，同上

    - 接口作用：这个接口是在确定`pos`落在哪两个设置的颜色之间，根据新计算出的`pos`值得出最终的颜色

    ```cpp
    LColor LLinearGradient::computeColorByT(const LColor &startColor, const LColor &finalStopColor, double t)
    {
        int r = (1 - t) * startColor.red() + t * finalStopColor.red();
        int g = (1 - t) * startColor.green() + t * finalStopColor.green();
        int b = (1 - t) * startColor.blue() + t * finalStopColor.blue();
        return LColor(r, g, b);
    }
    ```

## 菜单

### LMenu

### LMenuItem

# 学习的点

## 画笔

### LPen

我以为这个类是拿来做画笔的相关绘制的，但其实设计并非我想的这样。这个类`LPen`只是一个数据存储类，保存了画笔需要的一些信息，例如画笔宽度、画笔连接样式、画笔颜色等，真正管理绘画的类是绘画引擎类，对于`LPen`是`LDrawEngine`以及其下面的工具类，这些类里面保存了`LPen`对象，并且针对不同的绘画做了不同的处理，包括下面的画刷`LBrush`也是一样的道理

<img src="https://img-blog.csdnimg.cn/direct/81c0ae4e9f6d4684bc8d5c28bb60a5ac.png" alt="image-20240306104337531" style="zoom:85%;" />

## 画刷

### LBrush

也是一个数据存储类，具体思路见`LPen`，不再赘述

### LLinearGradient

1. 大致设计思路：

   - 这个类与`LBrush`类一起使用，以指定线形渐变笔刷，在类当中存储了渐变点起始坐标、结束坐标和标识的渐变点数组

     ```cpp
     /**
      * @brief 标识渐变起点坐标。
     */
     LPoint m_start;
     
     /**
      * @brief 标识渐变终点坐标。
     */                   
     LPoint m_finalStop;
     
     /**
     * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。
     */   
     LVector<LPair<double, LColor>> m_stops;
     ```

     - 第一个参数是渐变比例参数，范围是`0~1`，如何理解？
     - 首先理解如何渐变，从起始点开始到结束点，连起来是一条线段，我们的`LBrush`是沿着这条线段进行颜色渐变，垂直线段的颜色是一样的；
     - 这个比例参数就是在线段上的比例对应位置想要设置的颜色，比如设置一个这个参数之后，左右的线段的渐变就被分为了两个区域，例如从黑到白变成黑到红到白，这两种的视觉效果是不一样的

   - 更多接口的作用见上面，基本每个接口都或多或少存在问题，就写在上面了

   - 可以通过一个测试程序看看效果

     ```cpp
     #include <iostream>
     
     #include "llineargradient.h"
     #include "lpair.h"
     #include "lvector.h"
     #include "ldrawwindow.h"
     #include "ldrawcontext.h"
     #include "lwindowapplication.h"
     
     int main(int argc, const char *argv[])
     {
         LWindowApplication app;
         LDrawWindow dw;
         LDrawContext *dc = dw.drawContext();
     
         LLinearGradient line(LPoint(100, 0), LPoint(300, 0)); // 渐变从(100,0)到(300,0)
         dc->setBrushGradient(line);
         dc->drawRect(LRect(0, 0, 400, 400));// 画一个矩形
     
         dw.show();
         app.exec();
     }
     ```

     执行下来大概就是这个结果

     <img src="https://img-blog.csdnimg.cn/direct/3e0c2d0988174464a1997154a67d829e.png" alt="image-20240307145534071" style="zoom:67%;" />

## 菜单

### LMenu

### LMenuItem

