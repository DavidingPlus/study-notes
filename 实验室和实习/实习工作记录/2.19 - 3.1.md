# 迭代任务

1. 走查线程与同步相关内容，包括线程管理、线程数据、互斥锁、读写锁

# 代码走查问题

## 线程管理

## 线程数据

## 互斥锁

### lmutex

1. 析构函数注释少写了句号（`。`）

   ~~~cpp
   /**
    * @brief 析构函数
    */
   ~LMutex();
   ~~~

2. 拷贝赋值函数少写了`const`

   ~~~cpp
   /**
    * @brief 禁止赋值构造。
    */
   LMutex &operator=(LMutex &) = delete;
   ~~~

   - 引申：在代码里面未禁用移动构造和赋值，针对互斥锁当前的情况，应当禁用移动构造和赋值函数

### lmutexcontext

1. 析构函数注释问题，同`lmutex`

### lposixmutexcontext

1. 析构函数注释问题，同`lmutex`

2. 析构函数和`trylock()`部分错误处理使用了`std::cerr`

   - `trylock()`这里可以理解，因为是试探能否加锁成功，不成功返回`false`，通过标准错误输出信息也可以
     - 另外，`std::cerr`对应的标准错流是无缓冲的，没必要使用`std::endl`再冲洗一次缓冲区，输出`'\n'`即可
   - 析构函数这里失败的话，建议使用异常处理

   ~~~cpp
   LPosixMutexContext::~LPosixMutexContext()
   {
       int res = pthread_mutex_destroy(&m_mutex);
       if (res != 0)
       {
           // Handle error properly
           std::cout << "pthread_mutex_destroy() gave error code: " << res << std::endl;
       }
   }
   
   bool LPosixMutexContext::tryLock()
   {
   	...
           
       else if (res == EBUSY)
       {
           std::cerr << "LMutex::tryLock(): Target mutex is busy." << std::endl;
           return false;
       }
   
       ...
   }
   ~~~

3. 在锁的构造函数当中，使用检错锁，但是在`lock()`当中未作重复加锁的针对性判断，具体见`./snippet/MutexLockTest`

   ~~~cpp
   void LPosixMutexContext::lock()
   {
       int res = pthread_mutex_lock(&m_mutex);
       if (res != 0)
       {
           throw LException(LString("互斥锁加锁失败，错误代码：").append(LString(res)));
       }
   }
   ~~~
   
   - `trylock()`的判断并无问题，经过验证普通锁和检错锁在`trylock()`下加锁失败返回的都是`EBUSY（16）`

### lwin32mutexcontext

1. 析构函数注释问题，同`lmutex`
2. `std::cerr`问题，同`lposixmutexcontext`

## 读写锁

### lreadwritelock

1. 拷贝赋值函数问题，同`lmutex`

### lposixreadwritelockcontext

1. 构造函数使用了静态初始化，经研究动态和静态的区别之后认为使用动态初始化可能好一点

   ~~~cpp
   LPosixReadWriteLockContext::LPosixReadWriteLockContext()
   {
       m_rwlock = PTHREAD_RWLOCK_INITIALIZER;
   }
   ~~~

   - 静态初始化出来的锁不需要手动释放了，在析构函数中调用了`destroy`，可能会出现不可预测的运行时问题
   - 互斥锁那边使用的是动态初始化，当然是因为需要设置检错锁必须这么做，但是个人认为为了保持代码风格的统一，建议使用动态初始化

2. `std::cerr`问题，同`lposixmutexcontext`

### lwin32readwritelockcontext

1. `std::cerr`问题，同`lposixmutexcontext`

# 学习的点

## 线程管理

## 线程数据

## 互斥锁

### lmutex

1. 为了做到平台适配，定义了统一基类`LPlatformMutexContext`指针，针对不同平台派生，使用多态进行处理，在后续的`lock()，trylock()，unlock()`中就很方便的使用`LPlatfromMutex`的接口即可

   在`LMutex`构造函数中，使用`#ifdef、#elif、#else、#endif`宏初始化指针

   ~~~cpp
   LMutex::LMutex()
   {
   #ifdef __unix__
       m_pMutexContext = new LPosixMutexContext();
   
   #elif _WIN32
       m_pMutexContext = new LWin32MutexContext();
   
   #else
       throw LException("无法创建互斥锁上下文：无法检测当前操作系统平台。");
   #endif
   }
   ~~~

### lmutexcontext

1. 是一个抽象基类，延申出`unix`和`win32`的各自派生，在类当中的函数都是纯虚函数，等待子类的覆写，由于无法实例化，因此需要在上层在做一层包装，也就是在`lmutex`中使用该类指针进行多态的管理，做到了平台无关

### lposixmutexcontext

1. 关于互斥锁属性中的普通锁和检错锁

   互斥锁属性通过`pthread_mutex_init()`进行设置，第一个参数是互斥锁指针，第二个参数是属性指针

   普通锁属性：`PTHREAD_MUTEX_TIMED_NP`，默认值，线程加锁之后，实际上在锁这里形成了等待队列

   检错锁属性：`PTHREAD_MUTEX_ERRORCHECK_NP`，和普通锁的区别是检测到自身重复加锁之后不会阻塞，而是返回`EDEADLK（35）`，这样可以一定程度上作加锁的安全检测

### lwin32mutexcontext

`win`平台下的互斥锁，官方文档：[Synchapi.h 标头 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/synchapi/)

1. 代码中使用`CRITICAL_SECTION`关键节对象代表互斥锁，值得注意的是`win`平台自身也具有互斥锁，二者的区别在于关键节对象只能单个进程的线程使用，不支持跨进程共享
2. 一些接口
   - `InitializeCriticalSection`、`DeleteCriticalSection`、`EnterCriticalSection`、`TryEnterCriticalSection`、`LeaveCriticalSection`，`CriticalSection`意为临界区，分别对应初始化、销毁、加锁、尝试加锁、解锁，其中只有尝试解锁`trylock()`有返回值，其他的函数均没有返回值，因此没有错误异常处理是正常的

## 读写锁

整体设计和互斥锁一样，这里不再赘述

### lposixreadwritelockcontext

1. 锁的静态初始化和动态初始化

   以读写锁为例

   - 静态初始化

   ~~~cpp
   pthread_rwlock_t m_rwlock = PTHREAD_RWLOCK_INITIALIZER;
   ~~~

   - 动态初始化

   ~~~cpp
   pthread_rwlock_t m_rwlock;
   pthread_rwlock_init(&m_rwlock, nullptr);
   ~~~

   二者的区别：

   - 静态初始化在编译期就初始化完毕；动态初始化在运行期
   - 静态初始化不能设置锁的相关属性，只能使用默认的；动态初始化可以
   - 静态初始化的锁存储在静态存储区；动态初始化在堆区
   - 静态初始化使用完毕之后不需要手动`destroy`；动态初始化需要

2. 读写锁的特别之处

   - 为什么有读写锁？为了增加效率，不同线程可以通过读锁同时读取，共享数据，但是不能修改；需要修改的时候使用排他的写锁
   - 在系统提供的`API`中，加锁有加读锁和加写锁两个，但是解锁只有一个，为什么？
     - 是因为同一个线程不可能同时持有读锁和写锁，否则会导致死锁，程序阻塞，具体见`./snippet/RwlockTest`
     - 读写锁明确了读锁就只能读，写锁就只能写，如果既要读又要写那还不如使用互斥锁
     - 因此只有一个解锁接口`unlock()`

### lwin32readwritelockcontext

1. 代码中使用`SRWLock`代表读写锁
2. 一些接口
   - `InitializeSRWLock`、`AcquireSRWLockShared`、`TryAcquireSRWLockShared`、`AcquireSRWLockExclusive`、`TryAcquireSRWLockExclusive`、`ReleaseSRWLockShared`、`ReleaseSRWLockExclusive`，其中只有`trylock()`有返回值，其他函数均没有返回值，不用做异常处理
3. `win32`下面，释放读写锁是分开的，没有统一的释放接口，只有各自释放的接口，共享读锁`ReleaseSRWLockShared`和排他写锁`ReleaseSRWLockExclusive`

